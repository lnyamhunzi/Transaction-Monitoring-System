{"file_contents":{"aml_controls.py":{"content":"\"\"\"\nAML Control Engine - Implementation of all 7 banking AML controls\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_, desc, func\n\nfrom models import Transaction, Customer, Alert\nfrom utils import calculate_transaction_velocity, get_customer_transaction_history\n\nlogger = logging.getLogger(__name__)\n\nclass AMLControlEngine:\n    \"\"\"Comprehensive AML Control Engine implementing all banking controls\"\"\"\n    \n    def __init__(self):\n        self.controls = {\n            \"staff_posting\": self._control_staff_posting,\n            \"unusual_incoming\": self._control_unusual_incoming,\n            \"small_profile_incoming\": self._control_small_profile_incoming,\n            \"unusual_outgoing_swift\": self._control_unusual_outgoing_swift,\n            \"small_profile_outgoing_swift\": self._control_small_profile_outgoing_swift,\n            \"cross_currency\": self._control_cross_currency,\n            \"sanctions_screening\": self._control_sanctions_screening\n        }\n    \n    async def run_all_controls(self, transaction_data: Dict[str, Any], db: Session) -> Dict[str, Dict]:\n        \"\"\"Run all AML controls on a transaction\"\"\"\n        results = {}\n        \n        for control_name, control_func in self.controls.items():\n            try:\n                result = await control_func(transaction_data, db)\n                results[control_name] = result\n                \n                if result['triggered']:\n                    logger.info(f\"AML Control {control_name} triggered for transaction {transaction_data.get('id', 'unknown')}\")\n                \n            except Exception as e:\n                logger.error(f\"Error running AML control {control_name}: {e}\")\n                results[control_name] = {\n                    'triggered': False,\n                    'risk_score': 0.0,\n                    'description': f\"Control error: {str(e)}\",\n                    'metadata': {}\n                }\n        \n        return results\n    \n    async def _control_staff_posting(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 1: AML Staff posting transactions into their own accounts\n        Flags transactions where staff post transactions onto their own accounts\n        or where suspense account is debited to credit a staff account\n        \"\"\"\n        processed_by = transaction_data.get('processed_by')\n        customer_id = transaction_data.get('customer_id')\n        counterparty_account = transaction_data.get('counterparty_account')\n        account_number = transaction_data.get('account_number')\n        \n        triggered = False\n        risk_score = 0.0\n        description = \"\"\n        metadata = {}\n        \n        # Check if staff is posting to their own account\n        if processed_by and customer_id:\n            # Assuming staff IDs follow a pattern or we have a staff table\n            if processed_by == customer_id or processed_by in customer_id:\n                triggered = True\n                risk_score = 0.9\n                description = \"Staff member posting transaction to own account\"\n                metadata = {\n                    'staff_id': processed_by,\n                    'customer_id': customer_id,\n                    'violation_type': 'self_posting'\n                }\n        \n        # Check for suspense account to staff account transfers\n        suspense_accounts = ['SUSPENSE', 'SUSP', '999999']\n        if any(susp in str(counterparty_account or '').upper() for susp in suspense_accounts):\n            # Check if destination is staff account\n            customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n            if customer and any(staff_indicator in customer.full_name.upper() \n                             for staff_indicator in ['STAFF', 'EMPLOYEE', 'EMP']):\n                triggered = True\n                risk_score = 0.85\n                description = \"Suspense account debited to credit staff account\"\n                metadata = {\n                    'suspense_account': counterparty_account,\n                    'staff_account': account_number,\n                    'violation_type': 'suspense_to_staff'\n                }\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': metadata\n        }\n    \n    async def _control_unusual_incoming(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 2: AML Unusual Transaction Customer - incoming transactions\n        Flags customers performing incoming transactions out of their normal historical profile\n        \"\"\"\n        customer_id = transaction_data.get('customer_id')\n        amount = transaction_data.get('base_amount', 0)\n        transaction_type = transaction_data.get('transaction_type')\n        \n        if transaction_type != 'CREDIT':\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Not an incoming transaction', 'metadata': {}}\n        \n        # Get customer's historical incoming transaction profile\n        thirty_days_ago = datetime.now() - timedelta(days=30)\n        historical_transactions = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.transaction_type == 'CREDIT',\n                Transaction.created_at >= thirty_days_ago,\n                Transaction.created_at < datetime.now()\n            )\n        ).all()\n        \n        if len(historical_transactions) < 7:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Insufficient transaction history', 'metadata': {}}\n        \n        # Calculate statistical measures\n        historical_amounts = [t.base_amount for t in historical_transactions]\n        avg_amount = sum(historical_amounts) / len(historical_amounts)\n        max_amount = max(historical_amounts)\n        \n        # Calculate standard deviation\n        variance = sum((x - avg_amount) ** 2 for x in historical_amounts) / len(historical_amounts)\n        std_dev = variance ** 0.5\n        \n        triggered = False\n        risk_score = 0.0\n        description = \"\"\n        \n        # Flag if current transaction is significantly higher than historical pattern\n        if amount > avg_amount + (3 * std_dev):\n            triggered = True\n            risk_score = min(0.8, (amount - avg_amount) / max_amount)\n            description = f\"Incoming transaction of {amount} significantly exceeds historical average of {avg_amount:.2f}\"\n        \n        # Additional check for frequency\n        today_transactions = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.transaction_type == 'CREDIT',\n                Transaction.created_at >= datetime.now().date()\n            )\n        ).count()\n        \n        avg_daily_frequency = len(historical_transactions) / 30\n        if today_transactions > avg_daily_frequency * 3:\n            triggered = True\n            risk_score = max(risk_score, 0.7)\n            description += f\" Unusual frequency: {today_transactions} transactions today vs average {avg_daily_frequency:.1f}\"\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': {\n                'historical_average': avg_amount,\n                'current_amount': amount,\n                'std_deviation': std_dev,\n                'frequency_today': today_transactions,\n                'avg_daily_frequency': avg_daily_frequency\n            }\n        }\n    \n    async def _control_small_profile_incoming(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 3: AML Small profile incoming transactions\n        Flags incoming transactions that deviate from usual customer profile \n        for accounts with less than 7 transactions in history\n        \"\"\"\n        customer_id = transaction_data.get('customer_id')\n        amount = transaction_data.get('base_amount', 0)\n        transaction_type = transaction_data.get('transaction_type')\n        \n        if transaction_type != 'CREDIT':\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Not an incoming transaction', 'metadata': {}}\n        \n        # Get total transaction history\n        total_transactions = db.query(Transaction).filter(\n            Transaction.customer_id == customer_id\n        ).count()\n        \n        if total_transactions >= 7:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Customer has sufficient transaction history', 'metadata': {}}\n        \n        # Get all historical transactions for limited profile analysis\n        historical_transactions = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.transaction_type == 'CREDIT'\n            )\n        ).all()\n        \n        if not historical_transactions:\n            # First transaction - apply basic threshold\n            if amount > 10000:  # USD 10,000 threshold for new customers\n                return {\n                    'triggered': True,\n                    'risk_score': 0.8,\n                    'description': f\"First incoming transaction of {amount} exceeds new customer threshold\",\n                    'metadata': {'transaction_count': 0, 'threshold_applied': 10000}\n                }\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'First transaction within acceptable range', 'metadata': {}}\n        \n        # For customers with 1-6 transactions, apply stricter deviation rules\n        historical_amounts = [t.base_amount for t in historical_transactions]\n        max_historical = max(historical_amounts)\n        avg_historical = sum(historical_amounts) / len(historical_amounts)\n        \n        triggered = False\n        risk_score = 0.0\n        description = \"\"\n        \n        # Flag if current transaction is 200% higher than previous maximum\n        if amount > max_historical * 2:\n            triggered = True\n            risk_score = 0.75\n            description = f\"Transaction amount {amount} is {amount/max_historical:.1f}x the previous maximum of {max_historical}\"\n        \n        # Flag if amount is 5x the historical average\n        elif amount > avg_historical * 5:\n            triggered = True\n            risk_score = 0.65\n            description = f\"Transaction amount {amount} is {amount/avg_historical:.1f}x the historical average of {avg_historical:.2f}\"\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': {\n                'transaction_count': total_transactions,\n                'historical_max': max_historical,\n                'historical_avg': avg_historical,\n                'current_amount': amount\n            }\n        }\n    \n    async def _control_unusual_outgoing_swift(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 4: SWIFT Unusual outgoing MT103 SWIFT transactions\n        Flags outgoing MX messages (ISO 20022) on SWIFT CBPR+ transactions \n        that deviate from usual customer profile for customers with >7 transactions\n        \"\"\"\n        customer_id = transaction_data.get('customer_id')\n        amount = transaction_data.get('base_amount', 0)\n        channel = transaction_data.get('channel', '').upper()\n        transaction_type = transaction_data.get('transaction_type')\n        counterparty_bank = transaction_data.get('counterparty_bank', '')\n        \n        # Only process outgoing SWIFT transactions\n        if transaction_type != 'DEBIT' or 'SWIFT' not in channel:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Not an outgoing SWIFT transaction', 'metadata': {}}\n        \n        # Check if customer has sufficient transaction history\n        total_transactions = db.query(Transaction).filter(\n            Transaction.customer_id == customer_id\n        ).count()\n        \n        if total_transactions <= 7:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Insufficient transaction history for this control', 'metadata': {}}\n        \n        # Get historical SWIFT outgoing transactions\n        ninety_days_ago = datetime.now() - timedelta(days=90)\n        historical_swift = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.transaction_type == 'DEBIT',\n                Transaction.channel.like('%SWIFT%'),\n                Transaction.created_at >= ninety_days_ago\n            )\n        ).all()\n        \n        if len(historical_swift) < 3:\n            # Flag unusual SWIFT activity for customers without SWIFT history\n            return {\n                'triggered': True,\n                'risk_score': 0.7,\n                'description': f\"Unusual SWIFT transaction - customer has no recent SWIFT history\",\n                'metadata': {'historical_swift_count': len(historical_swift), 'amount': amount}\n            }\n        \n        # Analyze historical SWIFT patterns\n        historical_amounts = [t.base_amount for t in historical_swift]\n        historical_banks = [t.counterparty_bank for t in historical_swift if t.counterparty_bank is not None]\n        \n        avg_amount = sum(historical_amounts) / len(historical_amounts)\n        max_amount = max(historical_amounts)\n        \n        # Calculate monthly SWIFT frequency\n        monthly_frequency = len(historical_swift) / 3  # 90 days = ~3 months\n        current_month_swift = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.transaction_type == 'DEBIT',\n                Transaction.channel.like('%SWIFT%'),\n                Transaction.created_at >= datetime.now().replace(day=1)\n            )\n        ).count()\n        \n        triggered = False\n        risk_score = 0.0\n        description = \"\"\n        metadata = {\n            'historical_swift_count': len(historical_swift),\n            'avg_amount': avg_amount,\n            'max_amount': max_amount,\n            'monthly_frequency': monthly_frequency,\n            'current_month_swift': current_month_swift\n        }\n        \n        # Flag unusual amount\n        if amount > max_amount * 2:\n            triggered = True\n            risk_score = 0.8\n            description = f\"SWIFT amount {amount} exceeds 2x historical maximum {max_amount}\"\n        elif amount > avg_amount * 5:\n            triggered = True\n            risk_score = 0.7\n            description = f\"SWIFT amount {amount} exceeds 5x historical average {avg_amount:.2f}\"\n        \n        # Flag unusual frequency\n        if current_month_swift > monthly_frequency * 3:\n            triggered = True\n            risk_score = max(risk_score, 0.65)\n            description += f\" Unusual SWIFT frequency: {current_month_swift} this month vs average {monthly_frequency:.1f}\"\n        \n        # Flag new destination bank\n        if counterparty_bank and counterparty_bank not in historical_banks:\n            risk_score = max(risk_score, 0.6)\n            if triggered:\n                description += f\" New destination bank: {counterparty_bank}\"\n            else:\n                triggered = True\n                risk_score = 0.6\n                description = f\"SWIFT to new destination bank: {counterparty_bank}\"\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': metadata\n        }\n    \n    async def _control_small_profile_outgoing_swift(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 5: SWIFT Small profile outgoing MT103 SWIFT transactions\n        Flags outgoing SWIFT transactions for customers with <7 transactions in history\n        \"\"\"\n        customer_id = transaction_data.get('customer_id')\n        amount = transaction_data.get('base_amount', 0)\n        channel = transaction_data.get('channel', '').upper()\n        transaction_type = transaction_data.get('transaction_type')\n        \n        # Only process outgoing SWIFT transactions\n        if transaction_type != 'DEBIT' or 'SWIFT' not in channel:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Not an outgoing SWIFT transaction', 'metadata': {}}\n        \n        # Check transaction history\n        total_transactions = db.query(Transaction).filter(\n            Transaction.customer_id == customer_id\n        ).count()\n        \n        if total_transactions >= 7:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Customer has sufficient transaction history', 'metadata': {}}\n        \n        # For small profile customers, SWIFT transactions are inherently suspicious\n        swift_history = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.channel.like('%SWIFT%')\n            )\n        ).count()\n        \n        triggered = True\n        risk_score = 0.8  # High risk for new customers doing SWIFT\n        description = f\"Small profile customer ({total_transactions} total transactions) attempting SWIFT transfer of {amount}\"\n        \n        # Increase risk score based on amount and lack of SWIFT history\n        if amount > 50000:  # High value SWIFT\n            risk_score = 0.9\n            description += f\" - High value SWIFT transaction\"\n        \n        if swift_history == 0:  # First SWIFT transaction\n            risk_score = min(0.95, risk_score + 0.1)\n            description += f\" - First SWIFT transaction for customer\"\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': {\n                'total_transactions': total_transactions,\n                'swift_history_count': swift_history,\n                'amount': amount\n            }\n        }\n    \n    async def _control_cross_currency(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 6: Cross currency transactions\n        Flags cross-currency transactions on RTGS, Internal transfers, Zipit channels\n        \"\"\"\n        channel = transaction_data.get('channel', '').upper()\n        currency = transaction_data.get('currency', 'USD')\n        amount = transaction_data.get('amount', 0)\n        base_currency = 'USD'  # System base currency\n        \n        # Only monitor specific channels\n        monitored_channels = ['RTGS', 'INTERNAL', 'ZIPIT']\n        if not any(ch in channel for ch in monitored_channels):\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Channel not monitored for cross-currency', 'metadata': {}}\n        \n        # Check if transaction involves currency conversion\n        if currency == base_currency:\n            return {'triggered': False, 'risk_score': 0.0, 'description': 'Same currency transaction', 'metadata': {}}\n        \n        # Flag cross-currency transaction\n        triggered = True\n        risk_score = 0.5  # Base risk for cross-currency\n        description = f\"Cross-currency transaction: {currency} to {base_currency} on {channel}\"\n        \n        # Increase risk based on amount and currency\n        if amount > 10000:\n            risk_score = 0.7\n            description += f\" - High value cross-currency transaction\"\n        \n        # Higher risk for certain currency pairs\n        high_risk_currencies = ['ZWL', 'ZAR', 'GBP', 'EUR']\n        if currency in high_risk_currencies:\n            risk_score = min(0.8, risk_score + 0.2)\n            description += f\" - Involves high-risk currency {currency}\"\n        \n        # Check customer's cross-currency history\n        customer_id = transaction_data.get('customer_id')\n        historical_cross_currency = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.currency != base_currency\n            )\n        ).count()\n        \n        if historical_cross_currency == 0:\n            risk_score = min(0.85, risk_score + 0.15)\n            description += f\" - First cross-currency transaction for customer\"\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': {\n                'from_currency': currency,\n                'to_currency': base_currency,\n                'channel': channel,\n                'amount': amount,\n                'cross_currency_history': historical_cross_currency\n            }\n        }\n    \n    async def _control_sanctions_screening(self, transaction_data: Dict[str, Any], db: Session) -> Dict:\n        \"\"\"\n        Control 7: AML sanction screening\n        Screens real-time customer transactions and onboarding against sanctions lists\n        Note: This is a simplified version - full implementation would involve \n        dedicated sanctions screening service\n        \"\"\"\n        customer_id = transaction_data.get('customer_id')\n        counterparty_name = transaction_data.get('counterparty_name', '')\n        counterparty_bank = transaction_data.get('counterparty_bank', '')\n        \n        # Get customer information\n        customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n        \n        # Basic sanctions keywords (in production, use comprehensive sanctions lists)\n        sanctions_keywords = [\n            'OFAC', 'SDN', 'BLOCKED', 'DENIED', 'TERRORIST', 'SANCTIONS',\n            'EMBARGO', 'FROZEN', 'IRAN', 'NORTH KOREA', 'SYRIA', 'CUBA'\n        ]\n        \n        triggered = False\n        risk_score = 0.0\n        description = \"\"\n        metadata = {}\n        \n        # Screen customer name\n        if customer:\n            customer_name_upper = customer.full_name.upper()\n            for keyword in sanctions_keywords:\n                if keyword in customer_name_upper:\n                    triggered = True\n                    risk_score = 1.0\n                    description = f\"Customer name contains sanctions keyword: {keyword}\"\n                    metadata['matched_entity'] = customer.full_name\n                    metadata['matched_keyword'] = keyword\n                    break\n        \n        # Screen counterparty name\n        if counterparty_name:\n            counterparty_upper = counterparty_name.upper()\n            for keyword in sanctions_keywords:\n                if keyword in counterparty_upper:\n                    triggered = True\n                    risk_score = 1.0\n                    description = f\"Counterparty name contains sanctions keyword: {keyword}\"\n                    metadata['matched_entity'] = counterparty_name\n                    metadata['matched_keyword'] = keyword\n                    break\n        \n        # Screen counterparty bank\n        if counterparty_bank:\n            bank_upper = counterparty_bank.upper()\n            for keyword in sanctions_keywords:\n                if keyword in bank_upper:\n                    triggered = True\n                    risk_score = 1.0\n                    description = f\"Counterparty bank contains sanctions keyword: {keyword}\"\n                    metadata['matched_entity'] = counterparty_bank\n                    metadata['matched_keyword'] = keyword\n                    break\n        \n        # Additional screening for high-risk countries\n        high_risk_countries = ['IRAN', 'NORTH KOREA', 'SYRIA', 'CUBA', 'RUSSIA', 'BELARUS']\n        narrative = transaction_data.get('narrative', '').upper()\n        for country in high_risk_countries:\n            if country in narrative or (counterparty_bank and country in counterparty_bank.upper()):\n                triggered = True\n                risk_score = max(risk_score, 0.9)\n                description += f\" Transaction involves high-risk country: {country}\"\n                metadata['high_risk_country'] = country\n                break\n        \n        return {\n            'triggered': triggered,\n            'risk_score': risk_score,\n            'description': description,\n            'metadata': metadata\n        }\n","size_bytes":24474},"case_management.py":{"content":"\"\"\"\nCase Management Service for AML investigations and workflow\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_, desc\n\nfrom models import Case, Alert, CaseActivity, CaseStatus\nfrom notification_service import NotificationService\n\nlogger = logging.getLogger(__name__)\n\nclass CaseManagementService:\n    \"\"\"Service for managing AML investigation cases\"\"\"\n    \n    def __init__(self):\n        self.notification_service = NotificationService()\n        \n        # SLA configurations (in hours)\n        self.sla_config = {\n            'CRITICAL': 4,\n            'HIGH': 24,\n            'MEDIUM': 72,\n            'LOW': 168  # 1 week\n        }\n        \n        # Case workflow states\n        self.valid_transitions = {\n            'OPEN': ['INVESTIGATING', 'CLOSED'],\n            'INVESTIGATING': ['PENDING_REVIEW', 'CLOSED', 'ESCALATED'],\n            'PENDING_REVIEW': ['INVESTIGATING', 'CLOSED', 'ESCALATED'],\n            'ESCALATED': ['INVESTIGATING', 'CLOSED'],\n            'CLOSED': []  # Final state\n        }\n    \n    async def create_case(self, alert: Alert, notes: str, assigned_to: str, db: Session) -> Case:\n        \"\"\"Create a new investigation case from an alert\"\"\"\n        try:\n            # Generate case number\n            case_number = await self.generate_case_number(db)\n            \n            # Determine case priority based on alert\n            priority = self.determine_case_priority(alert)\n            \n            # Calculate target completion date based on SLA\n            sla_hours = self.sla_config.get(priority, 72)\n            target_completion = datetime.now() + timedelta(hours=sla_hours)\n            \n            # Create case\n            case = Case(\n                alert_id=alert.id,\n                case_number=case_number,\n                title=f\"{alert.alert_type} - Customer {alert.transaction.customer_id}\",\n                description=f\"Investigation case created from alert: {alert.description}\",\n                status=CaseStatus.OPEN,\n                priority=priority,\n                assigned_to=assigned_to,\n                investigation_notes=notes,\n                target_completion_date=target_completion\n            )\n            \n            db.add(case)\n            db.flush()  # Get the case ID\n            \n            # Create initial activity\n            await self.log_case_activity(\n                case.id,\n                \"CASE_CREATED\",\n                f\"Case created from alert {alert.id}. Initial notes: {notes}\",\n                assigned_to,\n                db\n            )\n            \n            # Update alert status\n            # Note: Assignment will be handled through proper database update\n            db.query(Alert).filter(Alert.id == alert.id).update({\n                'assigned_to': assigned_to,\n                'status': 'INVESTIGATING'\n            })\n            \n            db.commit()\n            \n            # Send notification\n            await self.notification_service.send_case_notification(\n                case.id, \"CREATED\", assigned_to\n            )\n            \n            logger.info(f\"Created case {case.case_number} for alert {alert.id}\")\n            return case\n            \n        except Exception as e:\n            logger.error(f\"Error creating case: {e}\")\n            db.rollback()\n            raise\n    \n    async def update_case(self, case_id: str, updates: Dict[str, Any], updated_by: str, db: Session) -> Optional[Case]:\n        \"\"\"Update case with new information\"\"\"\n        try:\n            case = db.query(Case).filter(Case.id == case_id).first()\n            if not case:\n                return None\n            \n            old_status = case.status\n            old_assigned_to = case.assigned_to\n            \n            # Apply updates\n            for key, value in updates.items():\n                if hasattr(case, key) and value is not None:\n                    setattr(case, key, value)\n            \n            # Log status change\n            if 'status' in updates and updates['status'] != old_status:\n                await self.validate_status_transition(old_status, updates['status'])\n                await self.log_case_activity(\n                    case_id,\n                    \"STATUS_CHANGED\",\n                    f\"Status changed from {old_status} to {updates['status']}\",\n                    updated_by,\n                    db\n                )\n                \n                # Handle status-specific actions\n                await self.handle_status_change(case, old_status, updates['status'], db)\n            \n            # Log assignment change\n            if 'assigned_to' in updates and updates['assigned_to'] != old_assigned_to:\n                await self.log_case_activity(\n                    case_id,\n                    \"REASSIGNED\",\n                    f\"Case reassigned from {old_assigned_to} to {updates['assigned_to']}\",\n                    updated_by,\n                    db\n                )\n                \n                # Send notification to new assignee\n                await self.notification_service.send_case_notification(\n                    case_id, \"REASSIGNED\", updates['assigned_to']\n                )\n            \n            # Log notes update\n            if 'investigation_notes' in updates:\n                await self.log_case_activity(\n                    case_id,\n                    \"NOTES_UPDATED\",\n                    \"Investigation notes updated\",\n                    updated_by,\n                    db\n                )\n            \n            db.commit()\n            \n            logger.info(f\"Updated case {case.case_number}\")\n            return case\n            \n        except Exception as e:\n            logger.error(f\"Error updating case: {e}\")\n            db.rollback()\n            return None\n    \n    async def close_case(self, case_id: str, decision: str, rationale: str, decided_by: str, db: Session) -> bool:\n        \"\"\"Close a case with final decision\"\"\"\n        try:\n            case = db.query(Case).filter(Case.id == case_id).first()\n            if not case:\n                return False\n            \n            # Update case\n            case.status = CaseStatus.CLOSED\n            case.decision = decision\n            case.decision_rationale = rationale\n            case.decided_by = decided_by\n            case.decided_at = datetime.now()\n            case.actual_completion_date = datetime.now()\n            \n            # Calculate total investigation time\n            investigation_time = (datetime.now() - case.created_at).total_seconds() / 3600\n            case.total_hours_spent = investigation_time\n            \n            # Log closure\n            await self.log_case_activity(\n                case_id,\n                \"CASE_CLOSED\",\n                f\"Case closed with decision: {decision}. Rationale: {rationale}\",\n                decided_by,\n                db\n            )\n            \n            # Update related alert\n            if case.alert:\n                case.alert.status = \"CLOSED\"\n                case.alert.resolution_notes = f\"Case closed: {decision}\"\n                case.alert.reviewed_by = decided_by\n                case.alert.reviewed_at = datetime.now()\n            \n            # Handle SAR filing if required\n            if decision == \"SAR_FILED\":\n                await self.handle_sar_filing(case, db)\n            \n            db.commit()\n            \n            logger.info(f\"Closed case {case.case_number} with decision: {decision}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error closing case: {e}\")\n            db.rollback()\n            return False\n    \n    async def escalate_case(self, case_id: str, escalation_reason: str, escalated_by: str, escalated_to: str, db: Session) -> bool:\n        \"\"\"Escalate case to higher authority\"\"\"\n        try:\n            case = db.query(Case).filter(Case.id == case_id).first()\n            if not case:\n                return False\n            \n            # Update case\n            case.status = CaseStatus.ESCALATED\n            case.assigned_to = escalated_to\n            case.supervisor = escalated_to\n            \n            # Log escalation\n            await self.log_case_activity(\n                case_id,\n                \"ESCALATED\",\n                f\"Case escalated to {escalated_to}. Reason: {escalation_reason}\",\n                escalated_by,\n                db\n            )\n            \n            # Update related alert\n            if case.alert:\n                case.alert.escalated_to = escalated_to\n                case.alert.escalated_at = datetime.now()\n                case.alert.escalation_reason = escalation_reason\n            \n            db.commit()\n            \n            # Send escalation notification\n            await self.notification_service.send_case_notification(\n                case_id, \"ESCALATED\", escalated_to\n            )\n            \n            logger.info(f\"Escalated case {case.case_number} to {escalated_to}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error escalating case: {e}\")\n            db.rollback()\n            return False\n    \n    async def get_case_metrics(self, db: Session, days: int = 30) -> Dict[str, Any]:\n        \"\"\"Get case management metrics\"\"\"\n        try:\n            start_date = datetime.now() - timedelta(days=days)\n            \n            # Total cases\n            total_cases = db.query(Case).filter(Case.created_at >= start_date).count()\n            \n            # Cases by status\n            status_counts = {}\n            for status in CaseStatus:\n                count = db.query(Case).filter(\n                    and_(Case.created_at >= start_date, Case.status == status)\n                ).count()\n                status_counts[status.value] = count\n            \n            # Average resolution time\n            closed_cases = db.query(Case).filter(\n                and_(\n                    Case.created_at >= start_date,\n                    Case.status == CaseStatus.CLOSED,\n                    Case.actual_completion_date.isnot(None)\n                )\n            ).all()\n            \n            avg_resolution_hours = 0\n            if closed_cases:\n                total_hours = sum(case.total_hours_spent or 0 for case in closed_cases)\n                avg_resolution_hours = total_hours / len(closed_cases)\n            \n            # SLA compliance\n            sla_breached = 0\n            for case in closed_cases:\n                if case.actual_completion_date > case.target_completion_date:\n                    sla_breached += 1\n            \n            sla_compliance = 0\n            if closed_cases:\n                sla_compliance = ((len(closed_cases) - sla_breached) / len(closed_cases)) * 100\n            \n            # Cases by decision\n            decisions = {}\n            for case in closed_cases:\n                if case.decision:\n                    decisions[case.decision] = decisions.get(case.decision, 0) + 1\n            \n            return {\n                'total_cases': total_cases,\n                'status_distribution': status_counts,\n                'avg_resolution_hours': avg_resolution_hours,\n                'sla_compliance_percentage': sla_compliance,\n                'sla_breached_count': sla_breached,\n                'decision_distribution': decisions,\n                'active_cases': total_cases - status_counts.get('CLOSED', 0)\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting case metrics: {e}\")\n            return {}\n    \n    async def get_overdue_cases(self, db: Session) -> List[Case]:\n        \"\"\"Get cases that are past their SLA deadline\"\"\"\n        try:\n            now = datetime.now()\n            \n            overdue_cases = db.query(Case).filter(\n                and_(\n                    Case.target_completion_date < now,\n                    Case.status != CaseStatus.CLOSED\n                )\n            ).order_by(Case.target_completion_date).all()\n            \n            return overdue_cases\n            \n        except Exception as e:\n            logger.error(f\"Error getting overdue cases: {e}\")\n            return []\n    \n    async def generate_case_number(self, db: Session) -> str:\n        \"\"\"Generate unique case number\"\"\"\n        try:\n            # Format: AML-YYYY-NNNN\n            year = datetime.now().year\n            \n            # Get last case number for this year\n            last_case = db.query(Case).filter(\n                Case.case_number.like(f'AML-{year}-%')\n            ).order_by(desc(Case.case_number)).first()\n            \n            if last_case:\n                # Extract sequence number\n                last_seq = int(last_case.case_number.split('-')[-1])\n                new_seq = last_seq + 1\n            else:\n                new_seq = 1\n            \n            return f\"AML-{year}-{new_seq:04d}\"\n            \n        except Exception as e:\n            logger.error(f\"Error generating case number: {e}\")\n            return f\"AML-{datetime.now().year}-{datetime.now().microsecond:04d}\"\n    \n    def determine_case_priority(self, alert: Alert) -> str:\n        \"\"\"Determine case priority based on alert characteristics\"\"\"\n        if alert.alert_type == \"SANCTIONS_HIT\":\n            return \"CRITICAL\"\n        elif alert.risk_score >= 0.9:\n            return \"CRITICAL\"\n        elif alert.risk_score >= 0.7:\n            return \"HIGH\"\n        elif alert.risk_score >= 0.5:\n            return \"MEDIUM\"\n        else:\n            return \"LOW\"\n    \n    async def validate_status_transition(self, from_status: str, to_status: str):\n        \"\"\"Validate if status transition is allowed\"\"\"\n        valid_transitions = self.valid_transitions.get(from_status, [])\n        if to_status not in valid_transitions:\n            raise ValueError(f\"Invalid status transition from {from_status} to {to_status}\")\n    \n    async def handle_status_change(self, case: Case, old_status: str, new_status: str, db: Session):\n        \"\"\"Handle status-specific actions\"\"\"\n        if new_status == \"INVESTIGATING\":\n            # Reset SLA deadline if case is reopened\n            if old_status == \"PENDING_REVIEW\":\n                sla_hours = self.sla_config.get(case.priority, 72)\n                case.target_completion_date = datetime.now() + timedelta(hours=sla_hours)\n        \n        elif new_status == \"ESCALATED\":\n            # Extend SLA for escalated cases\n            case.target_completion_date = datetime.now() + timedelta(hours=48)\n    \n    async def log_case_activity(self, case_id: str, activity_type: str, description: str, performed_by: str, db: Session):\n        \"\"\"Log case activity for audit trail\"\"\"\n        try:\n            activity = CaseActivity(\n                case_id=case_id,\n                activity_type=activity_type,\n                description=description,\n                performed_by=performed_by\n            )\n            \n            db.add(activity)\n            \n        except Exception as e:\n            logger.error(f\"Error logging case activity: {e}\")\n    \n    async def handle_sar_filing(self, case: Case, db: Session):\n        \"\"\"Handle Suspicious Activity Report filing\"\"\"\n        try:\n            # Generate SAR reference\n            sar_reference = f\"SAR-{datetime.now().strftime('%Y%m%d')}-{case.case_number}\"\n            \n            # Update case\n            case.sar_filed = True\n            case.sar_reference = sar_reference\n            case.sar_filed_date = datetime.now()\n            \n            # Log SAR filing\n            await self.log_case_activity(\n                case.id,\n                \"SAR_FILED\",\n                f\"SAR filed with reference: {sar_reference}\",\n                case.decided_by,\n                db\n            )\n            \n            logger.info(f\"SAR filed for case {case.case_number} with reference {sar_reference}\")\n            \n        except Exception as e:\n            logger.error(f\"Error handling SAR filing: {e}\")\n","size_bytes":16093},"config.py":{"content":"\"\"\"\nConfiguration settings for the AML Transaction Monitoring System\n\"\"\"\n\nimport os\nfrom typing import Dict, Any\n\nclass Settings:\n    \"\"\"Application settings and configuration\"\"\"\n    \n    # Database Configuration\n    DATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"postgresql://postgres:password@localhost:5432/aml_system\")\n    \n    # Application Settings\n    APP_NAME: str = \"Banking AML Transaction Monitoring System\"\n    APP_VERSION: str = \"1.0.0\"\n    DEBUG: bool = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n    SECRET_KEY: str = os.getenv(\"SECRET_KEY\", \"aml-system-secret-key-change-in-production\")\n    \n    # Server Configuration\n    HOST: str = os.getenv(\"HOST\", \"0.0.0.0\")\n    PORT: int = int(os.getenv(\"PORT\", \"5000\"))\n    \n    # Security Settings\n    JWT_SECRET_KEY: str = os.getenv(\"JWT_SECRET_KEY\", \"jwt-secret-key\")\n    JWT_ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    \n    # Email Configuration\n    SMTP_SERVER: str = os.getenv(\"SMTP_SERVER\", \"smtp.gmail.com\")\n    SMTP_PORT: int = int(os.getenv(\"SMTP_PORT\", \"587\"))\n    SMTP_USERNAME: str = os.getenv(\"SMTP_USERNAME\", \"aml-system@bank.com\")\n    SMTP_PASSWORD: str = os.getenv(\"SMTP_PASSWORD\", \"password\")\n    FROM_EMAIL: str = os.getenv(\"FROM_EMAIL\", \"aml-system@bank.com\")\n    \n    # Notification Recipients\n    COMPLIANCE_EMAILS: str = os.getenv(\"COMPLIANCE_EMAILS\", \"compliance@bank.com\")\n    MANAGEMENT_EMAILS: str = os.getenv(\"MANAGEMENT_EMAILS\", \"management@bank.com\")\n    AML_OFFICERS: str = os.getenv(\"AML_OFFICERS\", \"aml-officer@bank.com\")\n    TECH_EMAILS: str = os.getenv(\"TECH_EMAILS\", \"tech@bank.com\")\n    \n    # External API Configuration\n    EXCHANGE_RATE_API_KEY: str = os.getenv(\"EXCHANGE_RATE_API_KEY\", \"demo_key\")\n    \n    # AML Configuration\n    DEFAULT_RISK_THRESHOLD: float = 0.7\n    HIGH_VALUE_THRESHOLD_USD: float = 10000.0\n    \n    # Transaction Monitoring Thresholds\n    THRESHOLDS: Dict[str, Dict[str, float]] = {\n        \"USD\": {\n            \"low_risk\": 1000.0,\n            \"medium_risk\": 10000.0,\n            \"high_risk\": 50000.0,\n            \"reporting_threshold\": 10000.0\n        },\n        \"ZWL\": {\n            \"low_risk\": 1000000.0,\n            \"medium_risk\": 10000000.0,\n            \"high_risk\": 50000000.0,\n            \"reporting_threshold\": 10000000.0\n        },\n        \"ZAR\": {\n            \"low_risk\": 15000.0,\n            \"medium_risk\": 150000.0,\n            \"high_risk\": 750000.0,\n            \"reporting_threshold\": 150000.0\n        },\n        \"EUR\": {\n            \"low_risk\": 900.0,\n            \"medium_risk\": 9000.0,\n            \"high_risk\": 45000.0,\n            \"reporting_threshold\": 9000.0\n        },\n        \"GBP\": {\n            \"low_risk\": 800.0,\n            \"medium_risk\": 8000.0,\n            \"high_risk\": 40000.0,\n            \"reporting_threshold\": 8000.0\n        }\n    }\n    \n    # Channel Risk Weights\n    CHANNEL_RISK_WEIGHTS: Dict[str, float] = {\n        \"INTERNAL\": 0.1,\n        \"ATM\": 0.2,\n        \"POS\": 0.2,\n        \"MOBILE\": 0.3,\n        \"INTERNET\": 0.4,\n        \"BRANCH\": 0.3,\n        \"RTGS\": 0.6,\n        \"SWIFT\": 0.8,\n        \"ZIPIT\": 0.5\n    }\n    \n    # ML Model Configuration\n    ML_MODEL_PATH: str = os.getenv(\"ML_MODEL_PATH\", \"models/\")\n    MODEL_RETRAIN_INTERVAL_DAYS: int = 30\n    ANOMALY_DETECTION_THRESHOLD: float = 0.7\n    \n    # System Monitoring\n    LOG_LEVEL: str = os.getenv(\"LOG_LEVEL\", \"INFO\")\n    METRICS_ENABLED: bool = os.getenv(\"METRICS_ENABLED\", \"true\").lower() == \"true\"\n    \n    # SLA Configuration (in hours)\n    SLA_HOURS: Dict[str, int] = {\n        \"CRITICAL\": 4,\n        \"HIGH\": 24,\n        \"MEDIUM\": 72,\n        \"LOW\": 168\n    }\n    \n    # Sanctions Screening Configuration\n    SANCTIONS_SIMILARITY_THRESHOLD: float = 0.8\n    PEP_SIMILARITY_THRESHOLD: float = 0.85\n    SANCTIONS_UPDATE_INTERVAL_HOURS: int = 24\n    \n    # Rate Limiting\n    RATE_LIMIT_PER_MINUTE: int = 100\n    \n    # File Upload Configuration\n    MAX_UPLOAD_SIZE: int = 10 * 1024 * 1024  # 10MB\n    ALLOWED_EXTENSIONS: set = {'.csv', '.xlsx', '.json'}\n    \n    # Cache Configuration\n    REDIS_URL: str = os.getenv(\"REDIS_URL\", \"redis://localhost:6379/0\")\n    CACHE_TTL_SECONDS: int = 3600\n    \n    # Backup Configuration\n    BACKUP_ENABLED: bool = os.getenv(\"BACKUP_ENABLED\", \"true\").lower() == \"true\"\n    BACKUP_INTERVAL_HOURS: int = 24\n    BACKUP_RETENTION_DAYS: int = 30\n    \n    # Audit Configuration\n    AUDIT_LOG_RETENTION_DAYS: int = 2555  # 7 years\n    SENSITIVE_DATA_FIELDS: list = [\n        \"account_number\", \"id_number\", \"phone_number\", \"email\"\n    ]\n    \n    # Banking Integration Configuration\n    CBS_API_URL: str = os.getenv(\"CBS_API_URL\", \"http://localhost:8080/api\")\n    CBS_API_KEY: str = os.getenv(\"CBS_API_KEY\", \"cbs_api_key\")\n    CBS_TIMEOUT_SECONDS: int = 30\n    \n    GOAML_API_URL: str = os.getenv(\"GOAML_API_URL\", \"http://localhost:8081/api\")\n    GOAML_API_KEY: str = os.getenv(\"GOAML_API_KEY\", \"goaml_api_key\")\n    \n    # Data Retention Policy\n    TRANSACTION_RETENTION_YEARS: int = 7\n    ALERT_RETENTION_YEARS: int = 7\n    CASE_RETENTION_YEARS: int = 10\n    \n    # Performance Configuration\n    DB_POOL_SIZE: int = 20\n    DB_MAX_OVERFLOW: int = 30\n    DB_POOL_TIMEOUT: int = 30\n    \n    # Feature Flags\n    ENABLE_ML_SCORING: bool = os.getenv(\"ENABLE_ML_SCORING\", \"true\").lower() == \"true\"\n    ENABLE_REAL_TIME_SCREENING: bool = os.getenv(\"ENABLE_REAL_TIME_SCREENING\", \"true\").lower() == \"true\"\n    ENABLE_AUTO_CASE_CREATION: bool = os.getenv(\"ENABLE_AUTO_CASE_CREATION\", \"true\").lower() == \"true\"\n    \n    # Compliance Reporting\n    REGULATORY_REPORTING_ENABLED: bool = True\n    SAR_AUTO_FILING_ENABLED: bool = os.getenv(\"SAR_AUTO_FILING\", \"false\").lower() == \"true\"\n    \n    # Geographic Risk Configuration\n    HIGH_RISK_COUNTRIES: list = [\n        \"IRAN\", \"NORTH KOREA\", \"SYRIA\", \"CUBA\", \"AFGHANISTAN\",\n        \"YEMEN\", \"SOMALIA\", \"LIBYA\", \"IRAQ\", \"LEBANON\"\n    ]\n    \n    MEDIUM_RISK_COUNTRIES: list = [\n        \"RUSSIA\", \"BELARUS\", \"MYANMAR\", \"VENEZUELA\", \"NICARAGUA\",\n        \"ZIMBABWE\", \"ERITREA\", \"CENTRAL AFRICAN REPUBLIC\"\n    ]\n    \n    # Industry Risk Configuration\n    HIGH_RISK_INDUSTRIES: list = [\n        \"CASINO\", \"GAMING\", \"CRYPTOCURRENCY\", \"MONEY_EXCHANGE\",\n        \"PRECIOUS_METALS\", \"JEWELRY\", \"ARMS_DEALING\", \"ART_DEALING\"\n    ]\n    \n    # Customer Risk Configuration\n    PEP_ENHANCED_DUE_DILIGENCE: bool = True\n    NEW_CUSTOMER_MONITORING_DAYS: int = 90\n    DORMANT_ACCOUNT_THRESHOLD_DAYS: int = 365\n\n# Create settings instance\nsettings = Settings()\n\n# Configuration validation\ndef validate_config():\n    \"\"\"Validate configuration settings\"\"\"\n    errors = []\n    \n    # Required environment variables\n    required_vars = [\n        \"DATABASE_URL\",\n        \"SECRET_KEY\",\n        \"JWT_SECRET_KEY\"\n    ]\n    \n    for var in required_vars:\n        if not getattr(settings, var) or getattr(settings, var) == f\"{var.lower()}_placeholder\":\n            errors.append(f\"Required environment variable {var} is not set\")\n    \n    # Validate thresholds\n    for currency, thresholds in settings.THRESHOLDS.items():\n        if thresholds[\"low_risk\"] >= thresholds[\"medium_risk\"]:\n            errors.append(f\"Invalid threshold configuration for {currency}: low_risk >= medium_risk\")\n        if thresholds[\"medium_risk\"] >= thresholds[\"high_risk\"]:\n            errors.append(f\"Invalid threshold configuration for {currency}: medium_risk >= high_risk\")\n    \n    # Validate SLA hours\n    for priority, hours in settings.SLA_HOURS.items():\n        if hours <= 0:\n            errors.append(f\"Invalid SLA hours for {priority}: must be positive\")\n    \n    if errors:\n        raise ValueError(f\"Configuration validation failed: {'; '.join(errors)}\")\n\n# Validate configuration on import\nvalidate_config()\n","size_bytes":7676},"currency_service.py":{"content":"\"\"\"\nCurrency Service for exchange rate management and conversion\n\"\"\"\n\nimport logging\nimport requests\nimport os\nfrom typing import Dict, Optional\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import desc, and_\n\nfrom models import ExchangeRate\n\nlogger = logging.getLogger(__name__)\n\nclass CurrencyService:\n    \"\"\"Service for currency conversion and exchange rate management\"\"\"\n    \n    def __init__(self):\n        self.base_currency = \"USD\"\n        self.api_key = os.getenv(\"EXCHANGE_RATE_API_KEY\", \"demo_key\")\n        self.api_url = \"https://api.exchangerate-api.com/v4/latest\"\n        \n        # Supported currencies with their symbols\n        self.supported_currencies = {\n            'USD': {'symbol': '$', 'name': 'US Dollar'},\n            'ZWL': {'symbol': 'Z$', 'name': 'Zimbabwean Dollar'},\n            'ZAR': {'symbol': 'R', 'name': 'South African Rand'},\n            'EUR': {'symbol': '€', 'name': 'Euro'},\n            'GBP': {'symbol': '£', 'name': 'British Pound'},\n            'JPY': {'symbol': '¥', 'name': 'Japanese Yen'},\n            'CNY': {'symbol': '¥', 'name': 'Chinese Yuan'},\n            'AUD': {'symbol': 'A$', 'name': 'Australian Dollar'},\n            'CAD': {'symbol': 'C$', 'name': 'Canadian Dollar'},\n            'CHF': {'symbol': 'Fr', 'name': 'Swiss Franc'}\n        }\n        \n        # Manual exchange rates for currencies not available via API\n        self.manual_rates = {\n            'ZWL': 350.0  # ZWL to USD (highly volatile, manual update needed)\n        }\n    \n    async def convert_to_base(self, amount: float, from_currency: str) -> float:\n        \"\"\"Convert amount from given currency to base currency (USD)\"\"\"\n        try:\n            if from_currency == self.base_currency:\n                return amount\n            \n            # Get current exchange rate\n            rate = await self.get_exchange_rate(from_currency, self.base_currency)\n            \n            if rate is None:\n                logger.error(f\"Could not get exchange rate for {from_currency} to {self.base_currency}\")\n                return amount  # Return original amount if conversion fails\n            \n            converted_amount = amount / rate\n            \n            logger.info(f\"Converted {amount} {from_currency} to {converted_amount:.2f} {self.base_currency} at rate {rate}\")\n            \n            return converted_amount\n            \n        except Exception as e:\n            logger.error(f\"Error converting currency: {e}\")\n            return amount\n    \n    async def convert_amount(self, amount: float, from_currency: str, to_currency: str) -> Optional[float]:\n        \"\"\"Convert amount between any two supported currencies\"\"\"\n        try:\n            if from_currency == to_currency:\n                return amount\n            \n            # First convert to base currency, then to target currency\n            if from_currency != self.base_currency:\n                base_amount = await self.convert_to_base(amount, from_currency)\n            else:\n                base_amount = amount\n            \n            if to_currency == self.base_currency:\n                return base_amount\n            \n            # Convert from base to target currency\n            rate = await self.get_exchange_rate(self.base_currency, to_currency)\n            if rate is None:\n                return None\n            \n            return base_amount * rate\n            \n        except Exception as e:\n            logger.error(f\"Error converting between currencies: {e}\")\n            return None\n    \n    async def get_exchange_rate(self, from_currency: str, to_currency: str, db: Session = None) -> Optional[float]:\n        \"\"\"Get current exchange rate between two currencies\"\"\"\n        try:\n            # Check manual rates first\n            if from_currency in self.manual_rates:\n                return self.manual_rates[from_currency]\n            \n            # Check database for recent rates (less than 1 hour old)\n            if db:\n                recent_rate = db.query(ExchangeRate).filter(\n                    and_(\n                        ExchangeRate.from_currency == from_currency,\n                        ExchangeRate.to_currency == to_currency,\n                        ExchangeRate.rate_date >= datetime.now() - timedelta(hours=1)\n                    )\n                ).order_by(desc(ExchangeRate.rate_date)).first()\n                \n                if recent_rate:\n                    return recent_rate.rate\n            \n            # Fetch from API\n            rate = await self.fetch_rate_from_api(from_currency, to_currency)\n            \n            # Save to database if available\n            if rate and db:\n                await self.save_exchange_rate(from_currency, to_currency, rate, db)\n            \n            return rate\n            \n        except Exception as e:\n            logger.error(f\"Error getting exchange rate: {e}\")\n            return None\n    \n    async def fetch_rate_from_api(self, from_currency: str, to_currency: str) -> Optional[float]:\n        \"\"\"Fetch exchange rate from external API\"\"\"\n        try:\n            # Use different approach based on base currency\n            if from_currency == self.base_currency:\n                url = f\"{self.api_url}/{from_currency}\"\n                response = requests.get(url, timeout=10)\n                \n                if response.status_code == 200:\n                    data = response.json()\n                    rates = data.get('rates', {})\n                    return rates.get(to_currency)\n            else:\n                # Get rate via USD\n                usd_rate_from = await self.fetch_rate_from_api(from_currency, 'USD')\n                usd_rate_to = await self.fetch_rate_from_api('USD', to_currency)\n                \n                if usd_rate_from and usd_rate_to:\n                    return usd_rate_to / usd_rate_from\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error fetching rate from API: {e}\")\n            return None\n    \n    async def save_exchange_rate(self, from_currency: str, to_currency: str, rate: float, db: Session):\n        \"\"\"Save exchange rate to database\"\"\"\n        try:\n            exchange_rate = ExchangeRate(\n                from_currency=from_currency,\n                to_currency=to_currency,\n                rate=rate,\n                rate_date=datetime.now(),\n                source=\"API\"\n            )\n            \n            db.add(exchange_rate)\n            db.commit()\n            \n        except Exception as e:\n            logger.error(f\"Error saving exchange rate: {e}\")\n            db.rollback()\n    \n    async def get_supported_currencies(self) -> Dict[str, Dict[str, str]]:\n        \"\"\"Get list of supported currencies\"\"\"\n        return self.supported_currencies\n    \n    async def update_manual_rates(self, rates: Dict[str, float]):\n        \"\"\"Update manual exchange rates\"\"\"\n        try:\n            self.manual_rates.update(rates)\n            logger.info(f\"Updated manual rates: {rates}\")\n        except Exception as e:\n            logger.error(f\"Error updating manual rates: {e}\")\n    \n    async def get_currency_symbol(self, currency_code: str) -> str:\n        \"\"\"Get currency symbol\"\"\"\n        return self.supported_currencies.get(currency_code, {}).get('symbol', currency_code)\n    \n    async def get_currency_name(self, currency_code: str) -> str:\n        \"\"\"Get currency full name\"\"\"\n        return self.supported_currencies.get(currency_code, {}).get('name', currency_code)\n    \n    async def format_amount(self, amount: float, currency: str) -> str:\n        \"\"\"Format amount with currency symbol\"\"\"\n        try:\n            symbol = await self.get_currency_symbol(currency)\n            \n            # Format with appropriate decimal places\n            if currency in ['JPY']:  # Currencies without decimal places\n                return f\"{symbol}{amount:,.0f}\"\n            else:\n                return f\"{symbol}{amount:,.2f}\"\n                \n        except Exception as e:\n            logger.error(f\"Error formatting amount: {e}\")\n            return f\"{currency} {amount:.2f}\"\n    \n    async def validate_currency(self, currency_code: str) -> bool:\n        \"\"\"Validate if currency is supported\"\"\"\n        return currency_code in self.supported_currencies\n    \n    async def get_historical_rates(self, from_currency: str, to_currency: str, days: int, db: Session) -> list:\n        \"\"\"Get historical exchange rates\"\"\"\n        try:\n            start_date = datetime.now() - timedelta(days=days)\n            \n            rates = db.query(ExchangeRate).filter(\n                and_(\n                    ExchangeRate.from_currency == from_currency,\n                    ExchangeRate.to_currency == to_currency,\n                    ExchangeRate.rate_date >= start_date\n                )\n            ).order_by(ExchangeRate.rate_date).all()\n            \n            return [\n                {\n                    'date': rate.rate_date.strftime('%Y-%m-%d'),\n                    'rate': rate.rate,\n                    'source': rate.source\n                }\n                for rate in rates\n            ]\n            \n        except Exception as e:\n            logger.error(f\"Error getting historical rates: {e}\")\n            return []\n    \n    async def calculate_fx_risk(self, amount: float, from_currency: str, to_currency: str, db: Session) -> Dict:\n        \"\"\"Calculate foreign exchange risk metrics\"\"\"\n        try:\n            # Get historical rates for volatility calculation\n            historical_rates = await self.get_historical_rates(from_currency, to_currency, 30, db)\n            \n            if len(historical_rates) < 10:\n                return {'risk_level': 'UNKNOWN', 'volatility': 0.0, 'var_95': 0.0}\n            \n            # Calculate daily returns\n            rates = [r['rate'] for r in historical_rates]\n            returns = []\n            for i in range(1, len(rates)):\n                daily_return = (rates[i] - rates[i-1]) / rates[i-1]\n                returns.append(daily_return)\n            \n            # Calculate volatility (standard deviation of returns)\n            mean_return = sum(returns) / len(returns)\n            variance = sum((r - mean_return) ** 2 for r in returns) / len(returns)\n            volatility = variance ** 0.5\n            \n            # Calculate Value at Risk (95% confidence)\n            returns_sorted = sorted(returns)\n            var_index = int(len(returns_sorted) * 0.05)\n            var_95 = abs(returns_sorted[var_index]) if var_index < len(returns_sorted) else 0.0\n            \n            # Potential loss in base currency\n            potential_loss = amount * var_95\n            \n            # Risk level classification\n            if volatility < 0.02:\n                risk_level = 'LOW'\n            elif volatility < 0.05:\n                risk_level = 'MEDIUM'\n            else:\n                risk_level = 'HIGH'\n            \n            return {\n                'risk_level': risk_level,\n                'volatility': volatility,\n                'var_95': var_95,\n                'potential_loss': potential_loss,\n                'currency_pair': f\"{from_currency}/{to_currency}\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error calculating FX risk: {e}\")\n            return {'risk_level': 'UNKNOWN', 'volatility': 0.0, 'var_95': 0.0}\n","size_bytes":11424},"database.py":{"content":"\"\"\"\nDatabase configuration and session management\n\"\"\"\n\nimport os\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n# Database URL from environment variables\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql://postgres:password@localhost:5432/aml_system\")\n\n# Create database engine\nengine = create_engine(\n    DATABASE_URL,\n    poolclass=StaticPool,\n    pool_pre_ping=True,\n    pool_recycle=300,\n    echo=False  # Set to True for SQL query logging\n)\n\n# Create session factory\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_db():\n    \"\"\"Dependency to get database session\"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n","size_bytes":763},"main.py":{"content":"\"\"\"\nBanking AML and Transaction Monitoring System\nFastAPI backend with comprehensive transaction monitoring capabilities\n\"\"\"\n\nimport os\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, WebSocket, WebSocketDisconnect, Request\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import and_, or_, desc, func\nimport uvicorn\n\nfrom database import get_db, engine\nfrom models import *\nfrom aml_controls import AMLControlEngine\nfrom ml_engine import MLAnomlyEngine\nfrom risk_scoring import RiskScoringEngine\nfrom sanctions_screening import SanctionsScreeningEngine\nfrom notification_service import NotificationService\nfrom currency_service import CurrencyService\nfrom case_management import CaseManagementService\nfrom config import settings\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Create database tables\nBase.metadata.create_all(bind=engine)\n\n# Initialize services\naml_engine = AMLControlEngine()\nml_engine = MLAnomlyEngine()\nrisk_engine = RiskScoringEngine()\nsanctions_engine = SanctionsScreeningEngine()\nnotification_service = NotificationService()\ncurrency_service = CurrencyService()\ncase_service = CaseManagementService()\n\n# WebSocket connection manager for real-time updates\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n\n    async def broadcast(self, message: dict):\n        for connection in self.active_connections:\n            try:\n                await connection.send_json(message)\n            except:\n                pass\n\nmanager = ConnectionManager()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    logger.info(\"Starting Banking AML Transaction Monitoring System\")\n    # Initialize ML models\n    await ml_engine.initialize()\n    yield\n    # Shutdown\n    logger.info(\"Shutting down system\")\n\napp = FastAPI(\n    title=\"Banking AML Transaction Monitoring System\",\n    description=\"Professional AML compliance and transaction monitoring platform\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Static files and templates\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\ntemplates = Jinja2Templates(directory=\"templates\")\n\n# Security\nsecurity = HTTPBearer()\n\n# Pydantic models for API\nclass TransactionCreate(BaseModel):\n    customer_id: str\n    account_number: str\n    transaction_type: str\n    amount: float\n    currency: str = \"USD\"\n    channel: str\n    counterparty_account: Optional[str] = None\n    counterparty_name: Optional[str] = None\n    counterparty_bank: Optional[str] = None\n    reference: Optional[str] = None\n    narrative: Optional[str] = None\n\nclass AlertResponse(BaseModel):\n    id: str\n    alert_type: str\n    risk_score: float\n    status: str\n    created_at: datetime\n    transaction_id: str\n    customer_id: str\n    description: str\n\nclass CaseUpdate(BaseModel):\n    status: str\n    notes: str\n    assigned_to: Optional[str] = None\n\n# Authentication dependency\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    # In production, implement proper JWT validation\n    return {\"user_id\": \"admin\", \"role\": \"compliance_officer\"}\n\n# Frontend Routes\n@app.get(\"/\", response_class=HTMLResponse)\nasync def dashboard(request: Request):\n    return templates.TemplateResponse(\"dashboard.html\", {\"request\": request})\n\n@app.get(\"/admin\", response_class=HTMLResponse)\nasync def admin_panel(request: Request):\n    return templates.TemplateResponse(\"admin.html\", {\"request\": request})\n\n@app.get(\"/cases\", response_class=HTMLResponse)\nasync def case_management(request: Request):\n    return templates.TemplateResponse(\"case-management.html\", {\"request\": request})\n\n@app.get(\"/alerts\", response_class=HTMLResponse)\nasync def alerts_view(request: Request):\n    return templates.TemplateResponse(\"alerts.html\", {\"request\": request})\n\n@app.get(\"/reports\", response_class=HTMLResponse)\nasync def reports_view(request: Request):\n    return templates.TemplateResponse(\"reports.html\", {\"request\": request})\n\n# WebSocket endpoint for real-time updates\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n\n# API Endpoints\n\n@app.post(\"/api/transactions/\")\nasync def create_transaction(\n    transaction: TransactionCreate,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db),\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Process new transaction and run AML controls\"\"\"\n    \n    # Convert currency if needed\n    base_amount = await currency_service.convert_to_base(\n        transaction.amount, transaction.currency\n    )\n    \n    # Create transaction record\n    db_transaction = Transaction(\n        customer_id=transaction.customer_id,\n        account_number=transaction.account_number,\n        transaction_type=transaction.transaction_type,\n        amount=transaction.amount,\n        base_amount=base_amount,\n        currency=transaction.currency,\n        channel=transaction.channel,\n        counterparty_account=transaction.counterparty_account,\n        counterparty_name=transaction.counterparty_name,\n        counterparty_bank=transaction.counterparty_bank,\n        reference=transaction.reference,\n        narrative=transaction.narrative,\n        processed_by=current_user[\"user_id\"]\n    )\n    \n    db.add(db_transaction)\n    db.commit()\n    db.refresh(db_transaction)\n    \n    # Background processing for AML controls\n    background_tasks.add_task(\n        process_transaction_controls,\n        db_transaction.id,\n        transaction.dict()\n    )\n    \n    return {\"message\": \"Transaction processed\", \"transaction_id\": db_transaction.id}\n\nasync def process_transaction_controls(transaction_id: str, transaction_data: dict):\n    \"\"\"Background task to process AML controls\"\"\"\n    db = next(get_db())\n    \n    try:\n        # Run all AML controls\n        control_results = await aml_engine.run_all_controls(transaction_data, db)\n        \n        # Run ML anomaly detection\n        anomaly_score = await ml_engine.detect_anomaly(transaction_data, db)\n        \n        # Calculate risk score\n        risk_score = await risk_engine.calculate_risk_score(transaction_data, db)\n        \n        # Sanctions screening\n        sanctions_result = await sanctions_engine.screen_transaction(transaction_data, db)\n        \n        # Create alerts if necessary\n        alerts_created = []\n        \n        for control_name, result in control_results.items():\n            if result['triggered']:\n                alert = Alert(\n                    transaction_id=transaction_id,\n                    alert_type=f\"AML_{control_name}\",\n                    risk_score=result['risk_score'],\n                    description=result['description'],\n                    metadata=result['metadata'],\n                    status=\"OPEN\"\n                )\n                db.add(alert)\n                alerts_created.append(alert)\n        \n        if anomaly_score > 0.7:\n            alert = Alert(\n                transaction_id=transaction_id,\n                alert_type=\"ML_ANOMALY\",\n                risk_score=anomaly_score,\n                description=f\"ML anomaly detected with score {anomaly_score:.2f}\",\n                status=\"OPEN\"\n            )\n            db.add(alert)\n            alerts_created.append(alert)\n        \n        if sanctions_result['matched']:\n            alert = Alert(\n                transaction_id=transaction_id,\n                alert_type=\"SANCTIONS_HIT\",\n                risk_score=1.0,\n                description=f\"Sanctions match: {sanctions_result['details']}\",\n                status=\"OPEN\",\n                priority=\"HIGH\"\n            )\n            db.add(alert)\n            alerts_created.append(alert)\n        \n        db.commit()\n        \n        # Send real-time notifications\n        for alert in alerts_created:\n            await manager.broadcast({\n                \"type\": \"new_alert\",\n                \"alert\": {\n                    \"id\": alert.id,\n                    \"type\": alert.alert_type,\n                    \"risk_score\": alert.risk_score,\n                    \"description\": alert.description,\n                    \"created_at\": alert.created_at.isoformat()\n                }\n            })\n            \n            # Send email notification for high-risk alerts\n            if alert.risk_score > 0.8:\n                await notification_service.send_alert_email(alert)\n    \n    except Exception as e:\n        logger.error(f\"Error processing transaction controls: {e}\")\n    finally:\n        db.close()\n\n@app.get(\"/api/alerts/\")\nasync def get_alerts(\n    status: Optional[str] = None,\n    alert_type: Optional[str] = None,\n    limit: int = 100,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get alerts with optional filtering\"\"\"\n    query = db.query(Alert)\n    \n    if status:\n        query = query.filter(Alert.status == status)\n    if alert_type:\n        query = query.filter(Alert.alert_type == alert_type)\n    \n    alerts = query.options(db.joinedload(Alert.transaction)).order_by(desc(Alert.created_at)).limit(limit).all()\n    \n    return [\n        AlertResponse(\n            id=alert.id,\n            alert_type=alert.alert_type,\n            risk_score=alert.risk_score,\n            status=alert.status.value if hasattr(alert.status, 'value') else str(alert.status),\n            created_at=alert.created_at,\n            transaction_id=alert.transaction_id,\n            customer_id=alert.transaction.customer_id if alert.transaction else \"\",\n            description=alert.description\n        )\n        for alert in alerts\n    ]\n\n@app.get(\"/api/dashboard/stats\")\nasync def get_dashboard_stats(db: Session = Depends(get_db)):\n    \"\"\"Get dashboard statistics\"\"\"\n    today = datetime.now().date()\n    \n    # Transaction stats\n    today_transactions = db.query(Transaction).filter(\n        Transaction.created_at >= today\n    ).count()\n    \n    # Alert stats\n    open_alerts = db.query(Alert).filter(Alert.status == \"OPEN\").count()\n    high_risk_alerts = db.query(Alert).filter(\n        and_(Alert.status == \"OPEN\", Alert.risk_score >= 0.8)\n    ).count()\n    \n    # Risk distribution\n    risk_distribution = db.query(\n        Alert.alert_type,\n        func.avg(Alert.risk_score).label('avg_risk'),\n        func.count(Alert.id).label('count')\n    ).filter(Alert.created_at >= today).group_by(Alert.alert_type).all()\n    \n    return {\n        \"today_transactions\": today_transactions,\n        \"open_alerts\": open_alerts,\n        \"high_risk_alerts\": high_risk_alerts,\n        \"risk_distribution\": [\n            {\n                \"type\": item.alert_type,\n                \"avg_risk\": float(item.avg_risk or 0),\n                \"count\": item.count\n            }\n            for item in risk_distribution\n        ]\n    }\n\n@app.post(\"/api/cases/\")\nasync def create_case(\n    alert_id: str,\n    notes: str,\n    db: Session = Depends(get_db),\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Create a new case from an alert\"\"\"\n    alert = db.query(Alert).filter(Alert.id == alert_id).first()\n    if not alert:\n        raise HTTPException(status_code=404, detail=\"Alert not found\")\n    \n    case = await case_service.create_case(alert, notes, current_user[\"user_id\"], db)\n    return {\"message\": \"Case created\", \"case_id\": case.id}\n\n@app.put(\"/api/cases/{case_id}\")\nasync def update_case(\n    case_id: str,\n    update: CaseUpdate,\n    db: Session = Depends(get_db),\n    current_user: dict = Depends(get_current_user)\n):\n    \"\"\"Update case status and notes\"\"\"\n    case = await case_service.update_case(case_id, update.dict(), current_user[\"user_id\"], db)\n    if not case:\n        raise HTTPException(status_code=404, detail=\"Case not found\")\n    \n    return {\"message\": \"Case updated\"}\n\n@app.get(\"/api/reports/suspicious-activity\")\nasync def generate_sar_report(\n    start_date: datetime,\n    end_date: datetime,\n    db: Session = Depends(get_db)\n):\n    \"\"\"Generate Suspicious Activity Report\"\"\"\n    \n    # Get high-risk alerts in date range\n    alerts = db.query(Alert).filter(\n        and_(\n            Alert.created_at >= start_date,\n            Alert.created_at <= end_date,\n            Alert.risk_score >= 0.7\n        )\n    ).all()\n    \n    report_data = []\n    for alert in alerts:\n        transaction = alert.transaction\n        customer = db.query(Customer).filter(\n            Customer.customer_id == transaction.customer_id\n        ).first()\n        \n        report_data.append({\n            \"alert_id\": alert.id,\n            \"transaction_id\": transaction.id,\n            \"customer_name\": customer.full_name if customer else \"Unknown\",\n            \"account_number\": transaction.account_number,\n            \"amount\": transaction.amount,\n            \"currency\": transaction.currency,\n            \"risk_score\": alert.risk_score,\n            \"alert_type\": alert.alert_type,\n            \"description\": alert.description,\n            \"created_at\": alert.created_at.isoformat()\n        })\n    \n    return {\n        \"report_period\": {\n            \"start_date\": start_date.isoformat(),\n            \"end_date\": end_date.isoformat()\n        },\n        \"total_alerts\": len(report_data),\n        \"alerts\": report_data\n    }\n\n@app.get(\"/api/customers/{customer_id}/profile\")\nasync def get_customer_profile(customer_id: str, db: Session = Depends(get_db)):\n    \"\"\"Get customer transaction profile and risk assessment\"\"\"\n    \n    customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n    if not customer:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    # Get recent transactions\n    transactions = db.query(Transaction).filter(\n        Transaction.customer_id == customer_id\n    ).order_by(desc(Transaction.created_at)).limit(50).all()\n    \n    # Calculate profile metrics\n    total_volume = sum(t.base_amount for t in transactions)\n    avg_transaction = total_volume / len(transactions) if transactions else 0\n    \n    # Get alerts for this customer\n    customer_alerts = db.query(Alert).join(Transaction).filter(\n        Transaction.customer_id == customer_id\n    ).order_by(desc(Alert.created_at)).limit(10).all()\n    \n    return {\n        \"customer_id\": customer.customer_id,\n        \"full_name\": customer.full_name,\n        \"risk_rating\": customer.risk_rating,\n        \"account_opening_date\": customer.account_opening_date.isoformat(),\n        \"transaction_count\": len(transactions),\n        \"total_volume\": total_volume,\n        \"average_transaction\": avg_transaction,\n        \"recent_alerts\": len(customer_alerts),\n        \"transactions\": [\n            {\n                \"id\": t.id,\n                \"amount\": t.amount,\n                \"currency\": t.currency,\n                \"type\": t.transaction_type,\n                \"channel\": t.channel,\n                \"created_at\": t.created_at.isoformat()\n            }\n            for t in transactions[:10]  # Latest 10 for display\n        ]\n    }\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=5000,\n        reload=True,\n        log_level=\"info\"\n    )\n","size_bytes":16050},"ml_engine.py":{"content":"\"\"\"\nMachine Learning Engine for Anomaly Detection and Pattern Recognition\n\"\"\"\n\nimport logging\nimport pickle\nimport numpy as np\nimport pandas as pd\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, desc\nimport joblib\nfrom sklearn.ensemble import IsolationForest, RandomForestClassifier\nfrom sklearn.preprocessing import StandardScaler, LabelEncoder\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, confusion_matrix\n\nfrom models import Transaction, Customer, MLModel\nfrom utils import extract_transaction_features\n\nlogger = logging.getLogger(__name__)\n\nclass MLAnomlyEngine:\n    \"\"\"Machine Learning Engine for transaction anomaly detection\"\"\"\n    \n    def __init__(self):\n        self.anomaly_model = None\n        self.risk_model = None\n        self.scaler = StandardScaler()\n        self.label_encoder = LabelEncoder()\n        self.feature_columns = []\n        self.is_initialized = False\n    \n    async def initialize(self):\n        \"\"\"Initialize ML models\"\"\"\n        try:\n            await self.load_models()\n            if not self.anomaly_model:\n                logger.info(\"No trained models found, initializing with default models\")\n                await self.create_default_models()\n            self.is_initialized = True\n            logger.info(\"ML Engine initialized successfully\")\n        except Exception as e:\n            logger.error(f\"Error initializing ML Engine: {e}\")\n            self.is_initialized = False\n    \n    async def load_models(self):\n        \"\"\"Load trained models from disk\"\"\"\n        try:\n            self.anomaly_model = joblib.load('models/anomaly_detection_model.pkl')\n            self.risk_model = joblib.load('models/risk_classification_model.pkl')\n            self.scaler = joblib.load('models/feature_scaler.pkl')\n            with open('models/feature_columns.pkl', 'rb') as f:\n                self.feature_columns = pickle.load(f)\n            logger.info(\"ML models loaded successfully\")\n        except FileNotFoundError:\n            logger.info(\"No existing models found\")\n        except Exception as e:\n            logger.error(f\"Error loading models: {e}\")\n    \n    async def create_default_models(self):\n        \"\"\"Create default models with basic configuration\"\"\"\n        # Isolation Forest for anomaly detection\n        self.anomaly_model = IsolationForest(\n            contamination='auto',  # Auto detect contamination level\n            random_state=42,\n            n_estimators=100\n        )\n        \n        # Random Forest for risk classification\n        self.risk_model = RandomForestClassifier(\n            n_estimators=100,\n            random_state=42,\n            max_depth=10\n        )\n        \n        # Define basic feature columns\n        self.feature_columns = [\n            'amount', 'hour_of_day', 'day_of_week', 'is_weekend',\n            'customer_age_days', 'transaction_velocity_1h', 'transaction_velocity_24h',\n            'amount_percentile_30d', 'frequency_score', 'channel_encoded',\n            'transaction_type_encoded', 'currency_encoded'\n        ]\n    \n    async def detect_anomaly(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Detect anomalies in transaction using ML models\"\"\"\n        if not self.is_initialized or not self.anomaly_model:\n            return 0.0\n        \n        try:\n            # Extract features\n            features = await self.extract_features(transaction_data, db)\n            if not features:\n                return 0.0\n            \n            # Prepare feature vector\n            feature_vector = self.prepare_feature_vector(features)\n            \n            # Get anomaly score\n            anomaly_score = self.anomaly_model.decision_function([feature_vector])[0]\n            \n            # Convert to probability (0-1 scale)\n            normalized_score = max(0, min(1, (anomaly_score + 0.5)))\n            \n            return normalized_score\n            \n        except Exception as e:\n            logger.error(f\"Error in anomaly detection: {e}\")\n            return 0.0\n    \n    async def predict_risk_class(self, transaction_data: Dict[str, Any], db: Session) -> Dict[str, float]:\n        \"\"\"Predict risk class probabilities\"\"\"\n        if not self.is_initialized or not self.risk_model:\n            return {'LOW': 0.7, 'MEDIUM': 0.2, 'HIGH': 0.1}\n        \n        try:\n            # Extract features\n            features = await self.extract_features(transaction_data, db)\n            if not features:\n                return {'LOW': 0.7, 'MEDIUM': 0.2, 'HIGH': 0.1}\n            \n            # Prepare feature vector\n            feature_vector = self.prepare_feature_vector(features)\n            \n            # Get risk probabilities\n            probabilities = self.risk_model.predict_proba([feature_vector])[0]\n            \n            # Map to risk classes (assuming model was trained with LOW, MEDIUM, HIGH)\n            risk_classes = ['LOW', 'MEDIUM', 'HIGH']\n            return dict(zip(risk_classes, probabilities))\n            \n        except Exception as e:\n            logger.error(f\"Error in risk prediction: {e}\")\n            return {'LOW': 0.7, 'MEDIUM': 0.2, 'HIGH': 0.1}\n    \n    async def extract_features(self, transaction_data: Dict[str, Any], db: Session) -> Dict[str, float]:\n        \"\"\"Extract comprehensive features for ML models\"\"\"\n        try:\n            customer_id = transaction_data.get('customer_id')\n            amount = transaction_data.get('base_amount', 0)\n            channel = transaction_data.get('channel', '')\n            transaction_type = transaction_data.get('transaction_type', '')\n            currency = transaction_data.get('currency', 'USD')\n            \n            # Get customer information\n            customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n            \n            # Time-based features\n            now = datetime.now()\n            hour_of_day = now.hour\n            day_of_week = now.weekday()\n            is_weekend = 1 if day_of_week >= 5 else 0\n            \n            # Customer features\n            customer_age_days = 0\n            if customer and customer.account_opening_date:\n                customer_age_days = (now - customer.account_opening_date).days\n            \n            # Transaction velocity features\n            velocity_1h = await self.calculate_transaction_velocity(customer_id, 1, db)\n            velocity_24h = await self.calculate_transaction_velocity(customer_id, 24, db)\n            \n            # Amount percentile in customer's 30-day history\n            amount_percentile_30d = await self.calculate_amount_percentile(customer_id, amount, 30, db)\n            \n            # Frequency score\n            frequency_score = await self.calculate_frequency_score(customer_id, db)\n            \n            # Encode categorical variables\n            channel_encoded = hash(channel) % 100  # Simple hash encoding\n            transaction_type_encoded = {'CREDIT': 1, 'DEBIT': 2, 'TRANSFER': 3}.get(transaction_type, 0)\n            currency_encoded = hash(currency) % 50\n            \n            features = {\n                'amount': amount,\n                'hour_of_day': hour_of_day,\n                'day_of_week': day_of_week,\n                'is_weekend': is_weekend,\n                'customer_age_days': customer_age_days,\n                'transaction_velocity_1h': velocity_1h,\n                'transaction_velocity_24h': velocity_24h,\n                'amount_percentile_30d': amount_percentile_30d,\n                'frequency_score': frequency_score,\n                'channel_encoded': channel_encoded,\n                'transaction_type_encoded': transaction_type_encoded,\n                'currency_encoded': currency_encoded\n            }\n            \n            return features\n            \n        except Exception as e:\n            logger.error(f\"Error extracting features: {e}\")\n            return {}\n    \n    async def calculate_transaction_velocity(self, customer_id: str, hours: int, db: Session) -> float:\n        \"\"\"Calculate transaction velocity (count per hour)\"\"\"\n        try:\n            start_time = datetime.now() - timedelta(hours=hours)\n            \n            transaction_count = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= start_time\n                )\n            ).count()\n            \n            return transaction_count / hours\n            \n        except Exception as e:\n            logger.error(f\"Error calculating transaction velocity: {e}\")\n            return 0.0\n    \n    async def calculate_amount_percentile(self, customer_id: str, amount: float, days: int, db: Session) -> float:\n        \"\"\"Calculate percentile rank of amount in customer's historical transactions\"\"\"\n        try:\n            start_date = datetime.now() - timedelta(days=days)\n            \n            historical_amounts = db.query(Transaction.base_amount).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= start_date\n                )\n            ).all()\n            \n            if not historical_amounts:\n                return 0.5  # Default to median if no history\n            \n            amounts = [a[0] for a in historical_amounts]\n            amounts.sort()\n            \n            # Calculate percentile rank\n            lower_count = sum(1 for a in amounts if a < amount)\n            equal_count = sum(1 for a in amounts if a == amount)\n            \n            percentile = (lower_count + 0.5 * equal_count) / len(amounts)\n            return percentile\n            \n        except Exception as e:\n            logger.error(f\"Error calculating amount percentile: {e}\")\n            return 0.5\n    \n    async def calculate_frequency_score(self, customer_id: str, db: Session) -> float:\n        \"\"\"Calculate frequency score based on recent transaction patterns\"\"\"\n        try:\n            # Count transactions in different time windows\n            now = datetime.now()\n            \n            count_1h = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= now - timedelta(hours=1)\n                )\n            ).count()\n            \n            count_24h = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= now - timedelta(hours=24)\n                )\n            ).count()\n            \n            count_7d = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= now - timedelta(days=7)\n                )\n            ).count()\n            \n            # Weight recent activity more heavily\n            frequency_score = (count_1h * 10) + (count_24h * 2) + (count_7d * 0.5)\n            \n            return min(frequency_score, 100)  # Cap at 100\n            \n        except Exception as e:\n            logger.error(f\"Error calculating frequency score: {e}\")\n            return 0.0\n    \n    def prepare_feature_vector(self, features: Dict[str, float]) -> List[float]:\n        \"\"\"Prepare feature vector for model input\"\"\"\n        try:\n            # Ensure all required features are present\n            feature_vector = []\n            for col in self.feature_columns:\n                feature_vector.append(features.get(col, 0.0))\n            \n            return feature_vector\n            \n        except Exception as e:\n            logger.error(f\"Error preparing feature vector: {e}\")\n            return [0.0] * len(self.feature_columns)\n    \n    async def train_models(self, db: Session, days_back: int = 90):\n        \"\"\"Train ML models using historical data\"\"\"\n        try:\n            logger.info(f\"Starting model training with {days_back} days of data\")\n            \n            # Get training data\n            start_date = datetime.now() - timedelta(days=days_back)\n            transactions = db.query(Transaction).filter(\n                Transaction.created_at >= start_date\n            ).all()\n            \n            if len(transactions) < 1000:\n                logger.warning(\"Insufficient data for training\")\n                return False\n            \n            # Prepare training data\n            X, y_risk, y_anomaly = await self.prepare_training_data(transactions, db)\n            \n            if X.empty:\n                logger.error(\"No training data prepared\")\n                return False\n            \n            # Split data\n            X_train, X_test, y_risk_train, y_risk_test = train_test_split(\n                X, y_risk, test_size=0.2, random_state=42\n            )\n            \n            # Scale features\n            X_train_scaled = self.scaler.fit_transform(X_train)\n            X_test_scaled = self.scaler.transform(X_test)\n            \n            # Train anomaly detection model\n            self.anomaly_model.fit(X_train_scaled)\n            \n            # Train risk classification model\n            self.risk_model.fit(X_train_scaled, y_risk_train)\n            \n            # Evaluate models\n            risk_predictions = self.risk_model.predict(X_test_scaled)\n            logger.info(f\"Risk Classification Report:\\n{classification_report(y_risk_test, risk_predictions)}\")\n            \n            # Save models\n            await self.save_models()\n            \n            logger.info(\"Model training completed successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error training models: {e}\")\n            return False\n    \n    async def prepare_training_data(self, transactions: List[Transaction], db: Session):\n        \"\"\"Prepare training data from historical transactions\"\"\"\n        try:\n            training_data = []\n            \n            for transaction in transactions:\n                # Extract features for each transaction\n                transaction_data = {\n                    'customer_id': transaction.customer_id,\n                    'base_amount': transaction.base_amount,\n                    'channel': transaction.channel,\n                    'transaction_type': transaction.transaction_type,\n                    'currency': transaction.currency\n                }\n                \n                features = await self.extract_features(transaction_data, db)\n                \n                # Create risk label based on alerts\n                risk_label = 'LOW'\n                if transaction.alerts:\n                    max_risk_score = max(alert.risk_score for alert in transaction.alerts)\n                    if max_risk_score > 0.8:\n                        risk_label = 'HIGH'\n                    elif max_risk_score > 0.5:\n                        risk_label = 'MEDIUM'\n                \n                # Create anomaly label (simplified)\n                anomaly_label = 1 if risk_label == 'HIGH' else 0\n                \n                features['risk_label'] = risk_label\n                features['anomaly_label'] = anomaly_label\n                training_data.append(features)\n            \n            df = pd.DataFrame(training_data)\n            \n            # Separate features and labels\n            feature_cols = [col for col in df.columns if col not in ['risk_label', 'anomaly_label']]\n            X = df[feature_cols]\n            y_risk = df['risk_label']\n            y_anomaly = df['anomaly_label']\n            \n            return X, y_risk, y_anomaly\n            \n        except Exception as e:\n            logger.error(f\"Error preparing training data: {e}\")\n            return pd.DataFrame(), [], []\n    \n    async def save_models(self):\n        \"\"\"Save trained models to disk\"\"\"\n        try:\n            import os\n            os.makedirs('models', exist_ok=True)\n            \n            joblib.dump(self.anomaly_model, 'models/anomaly_detection_model.pkl')\n            joblib.dump(self.risk_model, 'models/risk_classification_model.pkl')\n            joblib.dump(self.scaler, 'models/feature_scaler.pkl')\n            \n            with open('models/feature_columns.pkl', 'wb') as f:\n                pickle.dump(self.feature_columns, f)\n            \n            logger.info(\"Models saved successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Error saving models: {e}\")\n","size_bytes":16566},"models.py":{"content":"\"\"\"\nDatabase models for Banking AML Transaction Monitoring System\n\"\"\"\n\nfrom sqlalchemy import Column, String, Float, DateTime, Boolean, Integer, Text, ForeignKey, JSON, Enum\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nimport uuid\nimport enum\n\nBase = declarative_base()\n\nclass RiskRating(enum.Enum):\n    LOW = \"LOW\"\n    MEDIUM = \"MEDIUM\"\n    HIGH = \"HIGH\"\n    CRITICAL = \"CRITICAL\"\n\nclass AlertStatus(enum.Enum):\n    OPEN = \"OPEN\"\n    INVESTIGATING = \"INVESTIGATING\"\n    CLOSED = \"CLOSED\"\n    FALSE_POSITIVE = \"FALSE_POSITIVE\"\n\nclass CaseStatus(enum.Enum):\n    OPEN = \"OPEN\"\n    INVESTIGATING = \"INVESTIGATING\"\n    PENDING_REVIEW = \"PENDING_REVIEW\"\n    CLOSED = \"CLOSED\"\n    ESCALATED = \"ESCALATED\"\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    customer_id = Column(String, unique=True, nullable=False, index=True)\n    full_name = Column(String, nullable=False)\n    date_of_birth = Column(DateTime)\n    nationality = Column(String)\n    id_number = Column(String)\n    phone_number = Column(String)\n    email = Column(String)\n    address = Column(Text)\n    occupation = Column(String)\n    employer = Column(String)\n    risk_rating = Column(Enum(RiskRating), default=RiskRating.LOW)\n    is_pep = Column(Boolean, default=False)\n    account_opening_date = Column(DateTime, nullable=False)\n    kyc_completion_date = Column(DateTime)\n    last_review_date = Column(DateTime)\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n    \n    # Relationships\n    transactions = relationship(\"Transaction\", back_populates=\"customer\")\n    alerts = relationship(\"Alert\", secondary=\"transaction\", back_populates=\"customer\")\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    account_number = Column(String, unique=True, nullable=False, index=True)\n    customer_id = Column(String, ForeignKey(\"customers.customer_id\"), nullable=False)\n    account_type = Column(String, nullable=False)  # SAVINGS, CURRENT, LOAN, etc.\n    currency = Column(String, default=\"USD\")\n    balance = Column(Float, default=0.0)\n    status = Column(String, default=\"ACTIVE\")  # ACTIVE, DORMANT, CLOSED, FROZEN\n    opening_date = Column(DateTime, nullable=False)\n    closing_date = Column(DateTime)\n    monthly_turnover_limit = Column(Float)\n    daily_transaction_limit = Column(Float)\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n\nclass Transaction(Base):\n    __tablename__ = \"transactions\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    customer_id = Column(String, ForeignKey(\"customers.customer_id\"), nullable=False, index=True)\n    account_number = Column(String, nullable=False, index=True)\n    transaction_type = Column(String, nullable=False)  # CREDIT, DEBIT, TRANSFER\n    amount = Column(Float, nullable=False)\n    base_amount = Column(Float, nullable=False)  # Amount in base currency (USD)\n    currency = Column(String, default=\"USD\")\n    exchange_rate = Column(Float, default=1.0)\n    channel = Column(String, nullable=False)  # RTGS, ZIPIT, INTERNAL, CARD, MOBILE\n    \n    # Counterparty information\n    counterparty_account = Column(String)\n    counterparty_name = Column(String)\n    counterparty_bank = Column(String)\n    counterparty_country = Column(String)\n    \n    # Transaction details\n    reference = Column(String)\n    narrative = Column(Text)\n    processing_date = Column(DateTime, server_default=func.now())\n    value_date = Column(DateTime)\n    \n    # Processing information\n    processed_by = Column(String)  # Staff member who processed\n    authorized_by = Column(String)  # Staff member who authorized\n    batch_id = Column(String)\n    \n    # Risk and compliance flags\n    risk_score = Column(Float, default=0.0)\n    is_suspicious = Column(Boolean, default=False)\n    is_cross_border = Column(Boolean, default=False)\n    is_high_value = Column(Boolean, default=False)\n    \n    # Audit trail\n    created_at = Column(DateTime, server_default=func.now(), index=True)\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n    \n    # Relationships\n    customer = relationship(\"Customer\", back_populates=\"transactions\")\n    alerts = relationship(\"Alert\", back_populates=\"transaction\")\n\nclass Alert(Base):\n    __tablename__ = \"alerts\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    transaction_id = Column(String, ForeignKey(\"transactions.id\"), nullable=False, index=True)\n    alert_type = Column(String, nullable=False, index=True)\n    risk_score = Column(Float, nullable=False)\n    priority = Column(String, default=\"MEDIUM\")  # LOW, MEDIUM, HIGH, CRITICAL\n    status = Column(Enum(AlertStatus), default=AlertStatus.OPEN, index=True)\n    \n    # Alert details\n    description = Column(Text, nullable=False)\n    triggered_rule = Column(String)\n    metadata = Column(JSON)  # Additional alert-specific data\n    \n    # Assignment and workflow\n    assigned_to = Column(String)  # Compliance officer assigned\n    reviewed_by = Column(String)\n    reviewed_at = Column(DateTime)\n    resolution_notes = Column(Text)\n    \n    # Escalation\n    escalated_to = Column(String)\n    escalated_at = Column(DateTime)\n    escalation_reason = Column(Text)\n    \n    # SLA tracking\n    sla_deadline = Column(DateTime)\n    response_time_minutes = Column(Integer)\n    resolution_time_minutes = Column(Integer)\n    \n    # Audit trail\n    created_at = Column(DateTime, server_default=func.now(), index=True)\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n    \n    # Relationships\n    transaction = relationship(\"Transaction\", back_populates=\"alerts\")\n    case = relationship(\"Case\", back_populates=\"alert\", uselist=False)\n\nclass Case(Base):\n    __tablename__ = \"cases\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    alert_id = Column(String, ForeignKey(\"alerts.id\"), nullable=False, unique=True)\n    case_number = Column(String, unique=True, nullable=False)\n    title = Column(String, nullable=False)\n    description = Column(Text)\n    status = Column(Enum(CaseStatus), default=CaseStatus.OPEN, index=True)\n    priority = Column(String, default=\"MEDIUM\")\n    \n    # Assignment\n    assigned_to = Column(String, nullable=False)\n    supervisor = Column(String)\n    \n    # Investigation details\n    investigation_notes = Column(Text)\n    evidence_collected = Column(JSON)\n    external_references = Column(JSON)  # Links to external systems\n    \n    # Decision and outcome\n    decision = Column(String)  # SAR_FILED, NO_ACTION, ACCOUNT_CLOSURE, etc.\n    decision_rationale = Column(Text)\n    decided_by = Column(String)\n    decided_at = Column(DateTime)\n    \n    # Regulatory reporting\n    sar_filed = Column(Boolean, default=False)\n    sar_reference = Column(String)\n    sar_filed_date = Column(DateTime)\n    \n    # SLA and metrics\n    target_completion_date = Column(DateTime)\n    actual_completion_date = Column(DateTime)\n    total_hours_spent = Column(Float, default=0.0)\n    \n    # Audit trail\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n    \n    # Relationships\n    alert = relationship(\"Alert\", back_populates=\"case\")\n    activities = relationship(\"CaseActivity\", back_populates=\"case\")\n\nclass CaseActivity(Base):\n    __tablename__ = \"case_activities\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    case_id = Column(String, ForeignKey(\"cases.id\"), nullable=False, index=True)\n    activity_type = Column(String, nullable=False)  # NOTE, STATUS_CHANGE, ASSIGNMENT, etc.\n    description = Column(Text, nullable=False)\n    performed_by = Column(String, nullable=False)\n    performed_at = Column(DateTime, server_default=func.now())\n    metadata = Column(JSON)\n    \n    # Relationships\n    case = relationship(\"Case\", back_populates=\"activities\")\n\nclass SanctionsList(Base):\n    __tablename__ = \"sanctions_lists\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    list_name = Column(String, nullable=False)  # OFAC, UN, EU, etc.\n    entity_name = Column(String, nullable=False, index=True)\n    entity_type = Column(String)  # INDIVIDUAL, ENTITY, VESSEL, etc.\n    aliases = Column(JSON)  # Alternative names\n    addresses = Column(JSON)\n    date_of_birth = Column(String)\n    place_of_birth = Column(String)\n    nationality = Column(String)\n    id_numbers = Column(JSON)\n    \n    # List metadata\n    list_date = Column(DateTime)\n    program = Column(String)\n    remarks = Column(Text)\n    \n    # System metadata\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n\nclass PEPList(Base):\n    __tablename__ = \"pep_lists\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    full_name = Column(String, nullable=False, index=True)\n    position = Column(String)\n    country = Column(String)\n    category = Column(String)  # HEAD_OF_STATE, MINISTER, JUDGE, etc.\n    start_date = Column(DateTime)\n    end_date = Column(DateTime)\n    is_active = Column(Boolean, default=True)\n    \n    # Additional information\n    aliases = Column(JSON)\n    family_members = Column(JSON)\n    close_associates = Column(JSON)\n    \n    # Source information\n    source = Column(String)\n    source_date = Column(DateTime)\n    \n    # System metadata\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n\nclass ExchangeRate(Base):\n    __tablename__ = \"exchange_rates\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    from_currency = Column(String, nullable=False, index=True)\n    to_currency = Column(String, nullable=False, index=True)\n    rate = Column(Float, nullable=False)\n    rate_date = Column(DateTime, nullable=False, index=True)\n    source = Column(String)  # CBZ, XE, BLOOMBERG, etc.\n    \n    # System metadata\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n\nclass SystemConfiguration(Base):\n    __tablename__ = \"system_configurations\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    config_key = Column(String, unique=True, nullable=False)\n    config_value = Column(String, nullable=False)\n    config_type = Column(String, default=\"STRING\")  # STRING, INTEGER, FLOAT, BOOLEAN, JSON\n    description = Column(Text)\n    category = Column(String)  # THRESHOLDS, ML_PARAMS, NOTIFICATIONS, etc.\n    \n    # Audit trail\n    created_by = Column(String)\n    updated_by = Column(String)\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n\nclass AuditLog(Base):\n    __tablename__ = \"audit_logs\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    user_id = Column(String, nullable=False, index=True)\n    action = Column(String, nullable=False)\n    resource_type = Column(String, nullable=False)  # TRANSACTION, ALERT, CASE, etc.\n    resource_id = Column(String, nullable=False)\n    old_values = Column(JSON)\n    new_values = Column(JSON)\n    ip_address = Column(String)\n    user_agent = Column(String)\n    timestamp = Column(DateTime, server_default=func.now(), index=True)\n\nclass MLModel(Base):\n    __tablename__ = \"ml_models\"\n    \n    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))\n    model_name = Column(String, unique=True, nullable=False)\n    model_type = Column(String, nullable=False)  # ANOMALY_DETECTION, RISK_SCORING, etc.\n    version = Column(String, nullable=False)\n    file_path = Column(String, nullable=False)\n    \n    # Model performance metrics\n    accuracy = Column(Float)\n    precision = Column(Float)\n    recall = Column(Float)\n    f1_score = Column(Float)\n    auc_score = Column(Float)\n    \n    # Model metadata\n    training_data_period = Column(String)\n    features_used = Column(JSON)\n    hyperparameters = Column(JSON)\n    \n    # Deployment information\n    is_active = Column(Boolean, default=False)\n    deployed_at = Column(DateTime)\n    deployed_by = Column(String)\n    \n    # System metadata\n    created_at = Column(DateTime, server_default=func.now())\n    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())\n","size_bytes":12822},"notification_service.py":{"content":"\"\"\"\nNotification Service for AML alerts and system notifications\n\"\"\"\n\nimport logging\nimport smtplib\nimport os\nfrom email.mime.text import MimeText\nfrom email.mime.multipart import MimeMultipart\nfrom typing import List, Dict, Any\nfrom datetime import datetime\nfrom jinja2 import Template\n\nfrom models import Alert, Transaction, Customer\n\nlogger = logging.getLogger(__name__)\n\nclass NotificationService:\n    \"\"\"Service for handling email notifications and alerts\"\"\"\n    \n    def __init__(self):\n        self.smtp_server = os.getenv(\"SMTP_SERVER\", \"smtp.gmail.com\")\n        self.smtp_port = int(os.getenv(\"SMTP_PORT\", \"587\"))\n        self.smtp_username = os.getenv(\"SMTP_USERNAME\", \"aml-system@bank.com\")\n        self.smtp_password = os.getenv(\"SMTP_PASSWORD\", \"password\")\n        self.from_email = os.getenv(\"FROM_EMAIL\", \"aml-system@bank.com\")\n        \n        # Recipient lists by alert type\n        self.compliance_team = os.getenv(\"COMPLIANCE_EMAILS\", \"compliance@bank.com\").split(\",\")\n        self.management_team = os.getenv(\"MANAGEMENT_EMAILS\", \"management@bank.com\").split(\",\")\n        self.aml_officers = os.getenv(\"AML_OFFICERS\", \"aml-officer@bank.com\").split(\",\")\n    \n    async def send_alert_email(self, alert: Alert) -> bool:\n        \"\"\"Send email notification for high-risk alerts\"\"\"\n        try:\n            # Determine recipients based on alert type and risk score\n            recipients = self._get_alert_recipients(alert)\n            \n            # Generate email content\n            subject = f\"AML Alert: {alert.alert_type} - Risk Score {alert.risk_score:.2f}\"\n            body = await self._generate_alert_email_body(alert)\n            \n            # Send email\n            success = await self._send_email(recipients, subject, body)\n            \n            if success:\n                logger.info(f\"Alert email sent successfully for alert {alert.id}\")\n            else:\n                logger.error(f\"Failed to send alert email for alert {alert.id}\")\n            \n            return success\n            \n        except Exception as e:\n            logger.error(f\"Error sending alert email: {e}\")\n            return False\n    \n    async def send_case_notification(self, case_id: str, action: str, assigned_to: str) -> bool:\n        \"\"\"Send notification for case management activities\"\"\"\n        try:\n            recipients = [assigned_to] + self.compliance_team\n            subject = f\"AML Case {action}: {case_id}\"\n            \n            body = f\"\"\"\n            <h2>AML Case Management Notification</h2>\n            <p><strong>Case ID:</strong> {case_id}</p>\n            <p><strong>Action:</strong> {action}</p>\n            <p><strong>Assigned To:</strong> {assigned_to}</p>\n            <p><strong>Time:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\n            <p>Please log into the AML system to review the case details.</p>\n            \"\"\"\n            \n            return await self._send_email(recipients, subject, body)\n            \n        except Exception as e:\n            logger.error(f\"Error sending case notification: {e}\")\n            return False\n    \n    async def send_daily_summary(self, stats: Dict[str, Any]) -> bool:\n        \"\"\"Send daily summary report to management\"\"\"\n        try:\n            recipients = self.management_team + self.compliance_team\n            subject = f\"AML Daily Summary - {datetime.now().strftime('%Y-%m-%d')}\"\n            \n            body = await self._generate_daily_summary_body(stats)\n            \n            return await self._send_email(recipients, subject, body)\n            \n        except Exception as e:\n            logger.error(f\"Error sending daily summary: {e}\")\n            return False\n    \n    async def send_system_alert(self, message: str, severity: str = \"INFO\") -> bool:\n        \"\"\"Send system-level alerts to technical team\"\"\"\n        try:\n            tech_team = os.getenv(\"TECH_EMAILS\", \"tech@bank.com\").split(\",\")\n            subject = f\"AML System Alert - {severity}\"\n            \n            body = f\"\"\"\n            <h2>AML System Alert</h2>\n            <p><strong>Severity:</strong> {severity}</p>\n            <p><strong>Message:</strong> {message}</p>\n            <p><strong>Time:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\n            \"\"\"\n            \n            return await self._send_email(tech_team, subject, body)\n            \n        except Exception as e:\n            logger.error(f\"Error sending system alert: {e}\")\n            return False\n    \n    def _get_alert_recipients(self, alert: Alert) -> List[str]:\n        \"\"\"Determine email recipients based on alert characteristics\"\"\"\n        recipients = []\n        \n        # Always include AML officers\n        recipients.extend(self.aml_officers)\n        \n        # High-risk alerts go to compliance team\n        if alert.risk_score >= 0.8:\n            recipients.extend(self.compliance_team)\n        \n        # Critical alerts (sanctions hits) go to management\n        if alert.alert_type == \"SANCTIONS_HIT\" or alert.risk_score >= 0.9:\n            recipients.extend(self.management_team)\n        \n        # Remove duplicates\n        return list(set(recipients))\n    \n    async def _generate_alert_email_body(self, alert: Alert) -> str:\n        \"\"\"Generate HTML email body for alerts\"\"\"\n        template_str = \"\"\"\n        <html>\n        <head>\n            <style>\n                body { font-family: Arial, sans-serif; margin: 20px; }\n                .header { background-color: #dc3545; color: white; padding: 15px; border-radius: 5px; }\n                .content { padding: 20px; border: 1px solid #ddd; border-radius: 5px; margin-top: 10px; }\n                .risk-high { color: #dc3545; font-weight: bold; }\n                .risk-medium { color: #ffc107; font-weight: bold; }\n                .risk-low { color: #28a745; font-weight: bold; }\n                table { width: 100%; border-collapse: collapse; margin: 15px 0; }\n                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n                th { background-color: #f8f9fa; }\n            </style>\n        </head>\n        <body>\n            <div class=\"header\">\n                <h2>🚨 AML Alert Notification</h2>\n            </div>\n            \n            <div class=\"content\">\n                <h3>Alert Details</h3>\n                <table>\n                    <tr><th>Alert ID</th><td>{{ alert.id }}</td></tr>\n                    <tr><th>Alert Type</th><td>{{ alert.alert_type }}</td></tr>\n                    <tr><th>Risk Score</th><td class=\"risk-{{ risk_class }}\">{{ alert.risk_score }}</td></tr>\n                    <tr><th>Priority</th><td>{{ alert.priority }}</td></tr>\n                    <tr><th>Status</th><td>{{ alert.status }}</td></tr>\n                    <tr><th>Created</th><td>{{ alert.created_at }}</td></tr>\n                </table>\n                \n                <h3>Transaction Details</h3>\n                <table>\n                    <tr><th>Transaction ID</th><td>{{ transaction.id }}</td></tr>\n                    <tr><th>Customer ID</th><td>{{ transaction.customer_id }}</td></tr>\n                    <tr><th>Amount</th><td>{{ transaction.currency }} {{ transaction.amount }}</td></tr>\n                    <tr><th>Channel</th><td>{{ transaction.channel }}</td></tr>\n                    <tr><th>Type</th><td>{{ transaction.transaction_type }}</td></tr>\n                </table>\n                \n                <h3>Description</h3>\n                <p>{{ alert.description }}</p>\n                \n                <h3>Action Required</h3>\n                <p>Please investigate this alert immediately and take appropriate action through the AML system.</p>\n                \n                <p><strong>Time Sensitive:</strong> This alert requires review within {{ sla_hours }} hours.</p>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        template = Template(template_str)\n        \n        # Determine risk class for styling\n        risk_class = \"high\" if alert.risk_score >= 0.8 else \"medium\" if alert.risk_score >= 0.5 else \"low\"\n        \n        # Calculate SLA hours based on risk score\n        sla_hours = 4 if alert.risk_score >= 0.8 else 24 if alert.risk_score >= 0.5 else 72\n        \n        return template.render(\n            alert=alert,\n            transaction=alert.transaction,\n            risk_class=risk_class,\n            sla_hours=sla_hours\n        )\n    \n    async def _generate_daily_summary_body(self, stats: Dict[str, Any]) -> str:\n        \"\"\"Generate daily summary email body\"\"\"\n        template_str = \"\"\"\n        <html>\n        <head>\n            <style>\n                body { font-family: Arial, sans-serif; margin: 20px; }\n                .header { background-color: #007bff; color: white; padding: 15px; border-radius: 5px; }\n                .content { padding: 20px; border: 1px solid #ddd; border-radius: 5px; margin-top: 10px; }\n                .metric { display: inline-block; margin: 10px; padding: 15px; background-color: #f8f9fa; border-radius: 5px; }\n                .metric h4 { margin: 0; color: #007bff; }\n                .metric p { margin: 5px 0; font-size: 24px; font-weight: bold; }\n                table { width: 100%; border-collapse: collapse; margin: 15px 0; }\n                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n                th { background-color: #f8f9fa; }\n            </style>\n        </head>\n        <body>\n            <div class=\"header\">\n                <h2>📊 AML Daily Summary Report</h2>\n                <p>{{ date }}</p>\n            </div>\n            \n            <div class=\"content\">\n                <h3>Key Metrics</h3>\n                <div class=\"metric\">\n                    <h4>Total Transactions</h4>\n                    <p>{{ stats.total_transactions }}</p>\n                </div>\n                \n                <div class=\"metric\">\n                    <h4>New Alerts</h4>\n                    <p>{{ stats.new_alerts }}</p>\n                </div>\n                \n                <div class=\"metric\">\n                    <h4>High Risk Alerts</h4>\n                    <p>{{ stats.high_risk_alerts }}</p>\n                </div>\n                \n                <div class=\"metric\">\n                    <h4>Cases Opened</h4>\n                    <p>{{ stats.cases_opened }}</p>\n                </div>\n                \n                <h3>Alert Breakdown by Type</h3>\n                <table>\n                    <tr><th>Alert Type</th><th>Count</th><th>Avg Risk Score</th></tr>\n                    {% for alert_type in stats.alert_breakdown %}\n                    <tr>\n                        <td>{{ alert_type.type }}</td>\n                        <td>{{ alert_type.count }}</td>\n                        <td>{{ alert_type.avg_risk }}</td>\n                    </tr>\n                    {% endfor %}\n                </table>\n                \n                <h3>Top Risk Customers</h3>\n                <table>\n                    <tr><th>Customer ID</th><th>Alert Count</th><th>Max Risk Score</th></tr>\n                    {% for customer in stats.top_risk_customers %}\n                    <tr>\n                        <td>{{ customer.customer_id }}</td>\n                        <td>{{ customer.alert_count }}</td>\n                        <td>{{ customer.max_risk_score }}</td>\n                    </tr>\n                    {% endfor %}\n                </table>\n                \n                <p><em>This is an automated report generated by the AML Transaction Monitoring System.</em></p>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        template = Template(template_str)\n        return template.render(\n            stats=stats,\n            date=datetime.now().strftime('%Y-%m-%d')\n        )\n    \n    async def _send_email(self, recipients: List[str], subject: str, body: str) -> bool:\n        \"\"\"Send email using SMTP\"\"\"\n        try:\n            # Create message\n            msg = MimeMultipart('alternative')\n            msg['Subject'] = subject\n            msg['From'] = self.from_email\n            msg['To'] = ', '.join(recipients)\n            \n            # Add HTML body\n            html_part = MimeText(body, 'html')\n            msg.attach(html_part)\n            \n            # Send email\n            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:\n                server.starttls()\n                server.login(self.smtp_username, self.smtp_password)\n                server.send_message(msg)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error sending email: {e}\")\n            return False\n","size_bytes":12630},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiofiles>=24.1.0\",\n    \"bcrypt>=4.3.0\",\n    \"fastapi>=0.116.1\",\n    \"jinja2>=3.1.6\",\n    \"joblib>=1.5.2\",\n    \"numpy>=2.3.2\",\n    \"pandas>=2.3.2\",\n    \"passlib>=1.7.4\",\n    \"psycopg2-binary>=2.9.10\",\n    \"pydantic>=2.11.7\",\n    \"python-jose>=3.5.0\",\n    \"python-multipart>=0.0.20\",\n    \"requests>=2.32.5\",\n    \"scikit-learn>=1.7.1\",\n    \"sqlalchemy>=2.0.43\",\n    \"uvicorn>=0.35.0\",\n]\n","size_bytes":531},"replit.md":{"content":"# Banking AML Transaction Monitoring System\n\n## Overview\n\nThis is a comprehensive Banking Anti-Money Laundering (AML) Transaction Monitoring System built with FastAPI. The system provides real-time monitoring of financial transactions, detecting suspicious activities through machine learning algorithms, rule-based controls, and sanctions screening. It implements 7 core AML controls including staff posting monitoring, unusual transaction detection, SWIFT transaction monitoring, cross-currency analysis, and sanctions screening. The system features a web-based dashboard for compliance officers, case management workflows, and automated reporting capabilities.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Framework\n- **FastAPI**: Python web framework for building the REST API with automatic OpenAPI documentation\n- **SQLAlchemy**: ORM for database operations with PostgreSQL as the primary database\n- **Pydantic**: Data validation and serialization using Python type hints\n\n### Database Design\n- **PostgreSQL**: Primary database for storing customers, transactions, alerts, and cases\n- **SQLAlchemy Models**: Comprehensive schema including Customer, Transaction, Alert, Case, SanctionsList, PEPList, and ExchangeRate tables\n- **Enum Types**: Structured status tracking for risk ratings, alert statuses, and case statuses\n\n### AML Control Engine\n- **Rule-Based Controls**: Seven distinct AML controls implemented as separate methods within a unified engine\n- **Machine Learning Integration**: Anomaly detection using Isolation Forest and Random Forest classifiers\n- **Risk Scoring**: Multi-factor risk assessment considering amount, frequency, customer profile, channel, geography, and behavior\n- **Real-time Processing**: All controls executed synchronously on each transaction\n\n### Machine Learning Components\n- **MLAnomlyEngine**: Implements unsupervised anomaly detection and supervised risk classification\n- **Model Persistence**: Trained models saved/loaded using joblib for consistency across sessions\n- **Feature Engineering**: Automated extraction of transaction features for ML processing\n- **Continuous Learning**: Framework for model retraining based on new data\n\n### Case Management System\n- **Workflow Engine**: Structured case lifecycle from creation through resolution\n- **SLA Management**: Automated tracking of investigation timelines based on risk levels\n- **Activity Logging**: Comprehensive audit trail of all case-related actions\n- **Assignment Logic**: Rule-based case routing to appropriate investigators\n\n### Frontend Architecture\n- **Server-Side Rendering**: Jinja2 templates for dynamic HTML generation\n- **Bootstrap 5**: Responsive CSS framework for professional banking interface\n- **Chart.js**: Interactive charts for data visualization and trend analysis\n- **DataTables**: Advanced table functionality with sorting, filtering, and pagination\n- **WebSocket Integration**: Real-time updates for dashboard and monitoring screens\n\n### Security and Authentication\n- **JWT Tokens**: Stateless authentication using JSON Web Tokens\n- **Role-Based Access**: Different permission levels for various user types\n- **Data Masking**: Sensitive information protection in logs and displays\n- **Secure Configuration**: Environment variable management for sensitive settings\n\n### Notification System\n- **SMTP Integration**: Email notifications for high-risk alerts and case updates\n- **Template Engine**: Dynamic email content generation using Jinja2\n- **Recipient Routing**: Smart notification routing based on alert type and severity\n- **Escalation Logic**: Automated escalation for time-sensitive alerts\n\n## External Dependencies\n\n### Currency Services\n- **Exchange Rate API**: Real-time currency conversion for multi-currency transaction analysis\n- **Manual Rate Override**: Support for currencies not available through standard APIs (e.g., ZWL)\n- **Historical Rate Storage**: Local caching of exchange rates for consistent reporting\n\n### Email Services\n- **SMTP Server**: Configurable email server for alert notifications\n- **Environment Configuration**: SMTP settings managed through environment variables\n- **Multi-Recipient Support**: Bulk email capabilities for compliance team notifications\n\n### Machine Learning Libraries\n- **scikit-learn**: Core ML algorithms for anomaly detection and classification\n- **pandas/numpy**: Data manipulation and numerical processing\n- **joblib**: Model serialization and persistence\n\n### Database Connections\n- **PostgreSQL**: Primary database with connection pooling and automatic reconnection\n- **SQLAlchemy Engine**: Database abstraction layer with connection management\n- **Migration Support**: Schema versioning through SQLAlchemy migrations\n\n### Web Framework Dependencies\n- **FastAPI Ecosystem**: Including Uvicorn ASGI server, Starlette middleware\n- **WebSocket Support**: Real-time bidirectional communication\n- **Static File Serving**: CSS, JavaScript, and asset management\n- **CORS Middleware**: Cross-origin request handling for frontend integration","size_bytes":5093},"risk_scoring.py":{"content":"\"\"\"\nRisk Scoring Engine for transaction risk assessment\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, desc, func\n\nfrom models import Transaction, Customer, Alert\nfrom utils import calculate_customer_risk_factors\n\nlogger = logging.getLogger(__name__)\n\nclass RiskScoringEngine:\n    \"\"\"Comprehensive risk scoring engine for transactions\"\"\"\n    \n    def __init__(self):\n        self.risk_weights = {\n            'amount_risk': 0.25,\n            'frequency_risk': 0.20,\n            'customer_risk': 0.20,\n            'channel_risk': 0.15,\n            'geographic_risk': 0.10,\n            'behavioral_risk': 0.10\n        }\n        \n        # Risk thresholds by currency\n        self.amount_thresholds = {\n            'USD': {'low': 1000, 'medium': 10000, 'high': 50000},\n            'ZWL': {'low': 1000000, 'medium': 10000000, 'high': 50000000},\n            'ZAR': {'low': 15000, 'medium': 150000, 'high': 750000},\n            'EUR': {'low': 900, 'medium': 9000, 'high': 45000},\n            'GBP': {'low': 800, 'medium': 8000, 'high': 40000}\n        }\n        \n        # Channel risk levels\n        self.channel_risks = {\n            'INTERNAL': 0.1,\n            'ATM': 0.2,\n            'POS': 0.2,\n            'MOBILE': 0.3,\n            'INTERNET': 0.4,\n            'BRANCH': 0.3,\n            'RTGS': 0.6,\n            'SWIFT': 0.8,\n            'ZIPIT': 0.5\n        }\n    \n    async def calculate_risk_score(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Calculate comprehensive risk score for a transaction\"\"\"\n        try:\n            # Calculate individual risk components\n            amount_risk = await self.calculate_amount_risk(transaction_data, db)\n            frequency_risk = await self.calculate_frequency_risk(transaction_data, db)\n            customer_risk = await self.calculate_customer_risk(transaction_data, db)\n            channel_risk = await self.calculate_channel_risk(transaction_data)\n            geographic_risk = await self.calculate_geographic_risk(transaction_data)\n            behavioral_risk = await self.calculate_behavioral_risk(transaction_data, db)\n            \n            # Calculate weighted risk score\n            total_score = (\n                (amount_risk * self.risk_weights['amount_risk']) +\n                (frequency_risk * self.risk_weights['frequency_risk']) +\n                (customer_risk * self.risk_weights['customer_risk']) +\n                (channel_risk * self.risk_weights['channel_risk']) +\n                (geographic_risk * self.risk_weights['geographic_risk']) +\n                (behavioral_risk * self.risk_weights['behavioral_risk'])\n            )\n            \n            # Ensure score is between 0 and 1\n            final_score = max(0.0, min(1.0, total_score))\n            \n            logger.info(f\"Risk score calculated: {final_score:.3f} (Amount: {amount_risk:.2f}, \"\n                       f\"Frequency: {frequency_risk:.2f}, Customer: {customer_risk:.2f}, \"\n                       f\"Channel: {channel_risk:.2f}, Geographic: {geographic_risk:.2f}, \"\n                       f\"Behavioral: {behavioral_risk:.2f})\")\n            \n            return final_score\n            \n        except Exception as e:\n            logger.error(f\"Error calculating risk score: {e}\")\n            return 0.5  # Default medium risk\n    \n    async def calculate_amount_risk(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Calculate risk based on transaction amount\"\"\"\n        try:\n            amount = transaction_data.get('base_amount', 0)\n            currency = transaction_data.get('currency', 'USD')\n            customer_id = transaction_data.get('customer_id')\n            \n            # Get currency-specific thresholds\n            thresholds = self.amount_thresholds.get(currency, self.amount_thresholds['USD'])\n            \n            # Base amount risk\n            if amount >= thresholds['high']:\n                amount_risk = 0.9\n            elif amount >= thresholds['medium']:\n                amount_risk = 0.6\n            elif amount >= thresholds['low']:\n                amount_risk = 0.3\n            else:\n                amount_risk = 0.1\n            \n            # Adjust based on customer's historical amounts\n            customer_avg = await self.get_customer_average_amount(customer_id, db)\n            if customer_avg > 0:\n                ratio = amount / customer_avg\n                if ratio > 10:  # 10x higher than average\n                    amount_risk = min(1.0, amount_risk + 0.3)\n                elif ratio > 5:  # 5x higher than average\n                    amount_risk = min(1.0, amount_risk + 0.2)\n                elif ratio > 2:  # 2x higher than average\n                    amount_risk = min(1.0, amount_risk + 0.1)\n            \n            return amount_risk\n            \n        except Exception as e:\n            logger.error(f\"Error calculating amount risk: {e}\")\n            return 0.3\n    \n    async def calculate_frequency_risk(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Calculate risk based on transaction frequency\"\"\"\n        try:\n            customer_id = transaction_data.get('customer_id')\n            \n            # Count transactions in different time windows\n            now = datetime.now()\n            \n            # Transactions in last hour\n            txn_1h = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= now - timedelta(hours=1)\n                )\n            ).count()\n            \n            # Transactions today\n            txn_today = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= now.replace(hour=0, minute=0, second=0)\n                )\n            ).count()\n            \n            # Transactions this week\n            week_start = now - timedelta(days=now.weekday())\n            txn_week = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= week_start\n                )\n            ).count()\n            \n            # Calculate frequency risk\n            frequency_risk = 0.0\n            \n            # High frequency in short time periods is suspicious\n            if txn_1h >= 5:\n                frequency_risk = 0.9\n            elif txn_1h >= 3:\n                frequency_risk = 0.7\n            elif txn_today >= 20:\n                frequency_risk = max(frequency_risk, 0.8)\n            elif txn_today >= 10:\n                frequency_risk = max(frequency_risk, 0.6)\n            elif txn_week >= 100:\n                frequency_risk = max(frequency_risk, 0.5)\n            elif txn_week >= 50:\n                frequency_risk = max(frequency_risk, 0.3)\n            else:\n                frequency_risk = 0.1\n            \n            return frequency_risk\n            \n        except Exception as e:\n            logger.error(f\"Error calculating frequency risk: {e}\")\n            return 0.2\n    \n    async def calculate_customer_risk(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Calculate risk based on customer profile\"\"\"\n        try:\n            customer_id = transaction_data.get('customer_id')\n            \n            customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n            if not customer:\n                return 0.8  # High risk for unknown customer\n            \n            customer_risk = 0.0\n            \n            # Risk based on customer rating\n            if customer.risk_rating.value == 'CRITICAL':\n                customer_risk = 0.9\n            elif customer.risk_rating.value == 'HIGH':\n                customer_risk = 0.7\n            elif customer.risk_rating.value == 'MEDIUM':\n                customer_risk = 0.4\n            else:  # LOW\n                customer_risk = 0.1\n            \n            # PEP status increases risk\n            if customer.is_pep:\n                customer_risk = min(1.0, customer_risk + 0.3)\n            \n            # New customer risk\n            if customer.account_opening_date:\n                days_since_opening = (datetime.now() - customer.account_opening_date).days\n                if days_since_opening < 30:  # New customer\n                    customer_risk = min(1.0, customer_risk + 0.2)\n                elif days_since_opening < 90:  # Recently opened\n                    customer_risk = min(1.0, customer_risk + 0.1)\n            \n            # High-risk occupations\n            high_risk_occupations = [\n                'POLITICIAN', 'GOVERNMENT', 'CASINO', 'EXCHANGE', 'DEALER',\n                'BROKER', 'ARMS', 'JEWELRY', 'PRECIOUS METALS'\n            ]\n            if customer.occupation:\n                for occupation in high_risk_occupations:\n                    if occupation in customer.occupation.upper():\n                        customer_risk = min(1.0, customer_risk + 0.2)\n                        break\n            \n            return customer_risk\n            \n        except Exception as e:\n            logger.error(f\"Error calculating customer risk: {e}\")\n            return 0.5\n    \n    async def calculate_channel_risk(self, transaction_data: Dict[str, Any]) -> float:\n        \"\"\"Calculate risk based on transaction channel\"\"\"\n        try:\n            channel = transaction_data.get('channel', '').upper()\n            \n            # Find matching channel risk\n            for channel_pattern, risk in self.channel_risks.items():\n                if channel_pattern in channel:\n                    return risk\n            \n            # Default risk for unknown channels\n            return 0.5\n            \n        except Exception as e:\n            logger.error(f\"Error calculating channel risk: {e}\")\n            return 0.3\n    \n    async def calculate_geographic_risk(self, transaction_data: Dict[str, Any]) -> float:\n        \"\"\"Calculate risk based on geographic factors\"\"\"\n        try:\n            counterparty_bank = transaction_data.get('counterparty_bank', '')\n            counterparty_country = transaction_data.get('counterparty_country', '')\n            \n            # High-risk countries\n            high_risk_countries = [\n                'IRAN', 'NORTH KOREA', 'SYRIA', 'CUBA', 'AFGHANISTAN',\n                'YEMEN', 'SOMALIA', 'LIBYA', 'IRAQ', 'LEBANON'\n            ]\n            \n            # Medium-risk countries\n            medium_risk_countries = [\n                'RUSSIA', 'BELARUS', 'MYANMAR', 'VENEZUELA', 'NICARAGUA',\n                'ZIMBABWE', 'ERITREA', 'CENTRAL AFRICAN REPUBLIC'\n            ]\n            \n            geographic_risk = 0.1  # Default low risk\n            \n            # Check counterparty country\n            if counterparty_country:\n                country_upper = counterparty_country.upper()\n                if any(country in country_upper for country in high_risk_countries):\n                    geographic_risk = 0.9\n                elif any(country in country_upper for country in medium_risk_countries):\n                    geographic_risk = 0.6\n            \n            # Check counterparty bank for geographic indicators\n            if counterparty_bank:\n                bank_upper = counterparty_bank.upper()\n                if any(country in bank_upper for country in high_risk_countries):\n                    geographic_risk = max(geographic_risk, 0.8)\n                elif any(country in bank_upper for country in medium_risk_countries):\n                    geographic_risk = max(geographic_risk, 0.5)\n            \n            return geographic_risk\n            \n        except Exception as e:\n            logger.error(f\"Error calculating geographic risk: {e}\")\n            return 0.2\n    \n    async def calculate_behavioral_risk(self, transaction_data: Dict[str, Any], db: Session) -> float:\n        \"\"\"Calculate risk based on behavioral patterns\"\"\"\n        try:\n            customer_id = transaction_data.get('customer_id')\n            current_hour = datetime.now().hour\n            current_day = datetime.now().weekday()\n            \n            behavioral_risk = 0.0\n            \n            # Time-based risk (unusual hours)\n            if current_hour < 6 or current_hour > 22:  # Very early or very late\n                behavioral_risk += 0.3\n            elif current_hour < 8 or current_hour > 20:  # Early or late\n                behavioral_risk += 0.1\n            \n            # Weekend transaction risk\n            if current_day >= 5:  # Saturday = 5, Sunday = 6\n                behavioral_risk += 0.2\n            \n            # Pattern deviation analysis\n            customer_patterns = await self.analyze_customer_patterns(customer_id, db)\n            \n            # Check if current transaction deviates from patterns\n            if customer_patterns:\n                # Time pattern deviation\n                usual_hours = customer_patterns.get('usual_hours', [])\n                if usual_hours and current_hour not in usual_hours:\n                    behavioral_risk += 0.2\n                \n                # Day pattern deviation\n                usual_days = customer_patterns.get('usual_days', [])\n                if usual_days and current_day not in usual_days:\n                    behavioral_risk += 0.1\n                \n                # Channel pattern deviation\n                current_channel = transaction_data.get('channel', '')\n                usual_channels = customer_patterns.get('usual_channels', [])\n                if usual_channels and current_channel not in usual_channels:\n                    behavioral_risk += 0.15\n            \n            # Recent alert history increases risk\n            recent_alerts = db.query(Alert).join(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Alert.created_at >= datetime.now() - timedelta(days=30)\n                )\n            ).count()\n            \n            if recent_alerts > 0:\n                behavioral_risk += min(0.3, recent_alerts * 0.1)\n            \n            return min(1.0, behavioral_risk)\n            \n        except Exception as e:\n            logger.error(f\"Error calculating behavioral risk: {e}\")\n            return 0.2\n    \n    async def get_customer_average_amount(self, customer_id: str, db: Session) -> float:\n        \"\"\"Get customer's average transaction amount\"\"\"\n        try:\n            thirty_days_ago = datetime.now() - timedelta(days=30)\n            \n            result = db.query(func.avg(Transaction.base_amount)).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= thirty_days_ago\n                )\n            ).scalar()\n            \n            return float(result) if result else 0.0\n            \n        except Exception as e:\n            logger.error(f\"Error calculating customer average amount: {e}\")\n            return 0.0\n    \n    async def analyze_customer_patterns(self, customer_id: str, db: Session) -> Dict[str, List]:\n        \"\"\"Analyze customer's transaction patterns\"\"\"\n        try:\n            sixty_days_ago = datetime.now() - timedelta(days=60)\n            \n            transactions = db.query(Transaction).filter(\n                and_(\n                    Transaction.customer_id == customer_id,\n                    Transaction.created_at >= sixty_days_ago\n                )\n            ).all()\n            \n            if len(transactions) < 5:  # Need minimum transactions for pattern analysis\n                return {}\n            \n            # Analyze patterns\n            hours = [t.created_at.hour for t in transactions]\n            days = [t.created_at.weekday() for t in transactions]\n            channels = [t.channel for t in transactions]\n            \n            # Find most common patterns (appearing in at least 30% of transactions)\n            threshold = len(transactions) * 0.3\n            \n            usual_hours = [h for h in set(hours) if hours.count(h) >= threshold]\n            usual_days = [d for d in set(days) if days.count(d) >= threshold]\n            usual_channels = [c for c in set(channels) if channels.count(c) >= threshold]\n            \n            return {\n                'usual_hours': usual_hours,\n                'usual_days': usual_days,\n                'usual_channels': usual_channels\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing customer patterns: {e}\")\n            return {}\n    \n    def get_risk_category(self, risk_score: float) -> str:\n        \"\"\"Convert risk score to risk category\"\"\"\n        if risk_score >= 0.8:\n            return \"CRITICAL\"\n        elif risk_score >= 0.6:\n            return \"HIGH\"\n        elif risk_score >= 0.4:\n            return \"MEDIUM\"\n        else:\n            return \"LOW\"\n    \n    def get_risk_description(self, risk_score: float) -> str:\n        \"\"\"Get risk description based on score\"\"\"\n        category = self.get_risk_category(risk_score)\n        \n        descriptions = {\n            \"CRITICAL\": \"Critical risk - immediate investigation required\",\n            \"HIGH\": \"High risk - priority investigation required\",\n            \"MEDIUM\": \"Medium risk - review recommended\",\n            \"LOW\": \"Low risk - routine monitoring\"\n        }\n        \n        return descriptions.get(category, \"Unknown risk level\")\n","size_bytes":17577},"sanctions_screening.py":{"content":"\"\"\"\nSanctions Screening Engine with fuzzy matching capabilities\n\"\"\"\n\nimport logging\nimport re\nfrom typing import Dict, Any, List, Tuple\nfrom difflib import SequenceMatcher\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import or_, func\n\nfrom models import SanctionsList, PEPList, Customer\n\nlogger = logging.getLogger(__name__)\n\nclass SanctionsScreeningEngine:\n    \"\"\"Advanced sanctions screening with fuzzy matching\"\"\"\n    \n    def __init__(self):\n        self.similarity_threshold = 0.8\n        self.phonetic_threshold = 0.85\n        \n        # Common name variations and abbreviations\n        self.name_variations = {\n            'COMPANY': ['CO', 'CORP', 'CORPORATION', 'LTD', 'LIMITED', 'INC', 'INCORPORATED'],\n            'BANK': ['BK', 'BANKING', 'BANQUE', 'BANCO'],\n            'INTERNATIONAL': ['INTL', 'INT\\'L', 'INTERNATIONAL'],\n            'FOUNDATION': ['FOUND', 'FDN'],\n            'ASSOCIATION': ['ASSOC', 'ASSN'],\n            'ORGANIZATION': ['ORG', 'ORGN']\n        }\n        \n        # Common transliterations\n        self.transliterations = {\n            'KH': 'H', 'PH': 'F', 'QU': 'KW', 'X': 'KS',\n            'Z': 'S', 'C': 'K', 'Y': 'I', 'J': 'I'\n        }\n    \n    async def screen_transaction(self, transaction_data: Dict[str, Any], db: Session) -> Dict[str, Any]:\n        \"\"\"Screen transaction against sanctions and PEP lists\"\"\"\n        try:\n            customer_id = transaction_data.get('customer_id')\n            counterparty_name = transaction_data.get('counterparty_name', '')\n            counterparty_bank = transaction_data.get('counterparty_bank', '')\n            \n            # Get customer information\n            customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n            \n            screening_results = {\n                'matched': False,\n                'matches': [],\n                'risk_score': 0.0,\n                'details': ''\n            }\n            \n            entities_to_screen = []\n            \n            # Add customer for screening\n            if customer:\n                entities_to_screen.append({\n                    'name': customer.full_name,\n                    'type': 'CUSTOMER',\n                    'date_of_birth': customer.date_of_birth,\n                    'nationality': customer.nationality\n                })\n            \n            # Add counterparty for screening\n            if counterparty_name:\n                entities_to_screen.append({\n                    'name': counterparty_name,\n                    'type': 'COUNTERPARTY',\n                    'date_of_birth': None,\n                    'nationality': None\n                })\n            \n            # Add counterparty bank for screening\n            if counterparty_bank:\n                entities_to_screen.append({\n                    'name': counterparty_bank,\n                    'type': 'BANK',\n                    'date_of_birth': None,\n                    'nationality': None\n                })\n            \n            # Screen each entity\n            for entity in entities_to_screen:\n                # Screen against sanctions lists\n                sanctions_matches = await self.screen_against_sanctions(entity, db)\n                \n                # Screen against PEP lists\n                pep_matches = await self.screen_against_peps(entity, db)\n                \n                # Combine results\n                all_matches = sanctions_matches + pep_matches\n                \n                if all_matches:\n                    screening_results['matched'] = True\n                    screening_results['matches'].extend(all_matches)\n                    \n                    # Calculate risk score based on match quality\n                    max_score = max(match['similarity_score'] for match in all_matches)\n                    screening_results['risk_score'] = max(screening_results['risk_score'], max_score)\n            \n            # Generate details\n            if screening_results['matched']:\n                match_count = len(screening_results['matches'])\n                highest_score = screening_results['risk_score']\n                screening_results['details'] = f\"Found {match_count} potential matches with highest similarity {highest_score:.2f}\"\n            else:\n                screening_results['details'] = \"No sanctions or PEP matches found\"\n            \n            return screening_results\n            \n        except Exception as e:\n            logger.error(f\"Error in sanctions screening: {e}\")\n            return {\n                'matched': False,\n                'matches': [],\n                'risk_score': 0.0,\n                'details': f\"Screening error: {str(e)}\"\n            }\n    \n    async def screen_against_sanctions(self, entity: Dict[str, Any], db: Session) -> List[Dict[str, Any]]:\n        \"\"\"Screen entity against sanctions lists\"\"\"\n        try:\n            entity_name = entity['name']\n            matches = []\n            \n            # Get all sanctions list entries\n            sanctions_entries = db.query(SanctionsList).all()\n            \n            for sanctions_entry in sanctions_entries:\n                # Primary name match\n                similarity = self.calculate_similarity(entity_name, sanctions_entry.entity_name)\n                \n                if similarity >= self.similarity_threshold:\n                    matches.append({\n                        'entity_type': 'SANCTIONS',\n                        'list_name': sanctions_entry.list_name,\n                        'matched_name': sanctions_entry.entity_name,\n                        'similarity_score': similarity,\n                        'match_type': 'PRIMARY_NAME',\n                        'sanctions_program': sanctions_entry.program,\n                        'entity_id': sanctions_entry.id\n                    })\n                \n                # Check aliases\n                if sanctions_entry.aliases:\n                    for alias in sanctions_entry.aliases:\n                        alias_similarity = self.calculate_similarity(entity_name, alias)\n                        \n                        if alias_similarity >= self.similarity_threshold:\n                            matches.append({\n                                'entity_type': 'SANCTIONS',\n                                'list_name': sanctions_entry.list_name,\n                                'matched_name': alias,\n                                'similarity_score': alias_similarity,\n                                'match_type': 'ALIAS',\n                                'sanctions_program': sanctions_entry.program,\n                                'entity_id': sanctions_entry.id\n                            })\n                \n                # Additional screening for date of birth if available\n                if (entity.get('date_of_birth') and sanctions_entry.date_of_birth and \n                    similarity >= 0.7):  # Lower threshold for name if DOB matches\n                    \n                    if self.compare_dates(entity['date_of_birth'], sanctions_entry.date_of_birth):\n                        matches.append({\n                            'entity_type': 'SANCTIONS',\n                            'list_name': sanctions_entry.list_name,\n                            'matched_name': sanctions_entry.entity_name,\n                            'similarity_score': min(1.0, similarity + 0.2),  # Boost score for DOB match\n                            'match_type': 'NAME_AND_DOB',\n                            'sanctions_program': sanctions_entry.program,\n                            'entity_id': sanctions_entry.id\n                        })\n            \n            return matches\n            \n        except Exception as e:\n            logger.error(f\"Error screening against sanctions: {e}\")\n            return []\n    \n    async def screen_against_peps(self, entity: Dict[str, Any], db: Session) -> List[Dict[str, Any]]:\n        \"\"\"Screen entity against PEP lists\"\"\"\n        try:\n            entity_name = entity['name']\n            matches = []\n            \n            # Get active PEP entries\n            pep_entries = db.query(PEPList).filter(PEPList.is_active == True).all()\n            \n            for pep_entry in pep_entries:\n                # Primary name match\n                similarity = self.calculate_similarity(entity_name, pep_entry.full_name)\n                \n                if similarity >= self.similarity_threshold:\n                    matches.append({\n                        'entity_type': 'PEP',\n                        'list_name': 'PEP_LIST',\n                        'matched_name': pep_entry.full_name,\n                        'similarity_score': similarity,\n                        'match_type': 'PRIMARY_NAME',\n                        'pep_position': pep_entry.position,\n                        'pep_country': pep_entry.country,\n                        'entity_id': pep_entry.id\n                    })\n                \n                # Check aliases\n                if pep_entry.aliases:\n                    for alias in pep_entry.aliases:\n                        alias_similarity = self.calculate_similarity(entity_name, alias)\n                        \n                        if alias_similarity >= self.similarity_threshold:\n                            matches.append({\n                                'entity_type': 'PEP',\n                                'list_name': 'PEP_LIST',\n                                'matched_name': alias,\n                                'similarity_score': alias_similarity,\n                                'match_type': 'ALIAS',\n                                'pep_position': pep_entry.position,\n                                'pep_country': pep_entry.country,\n                                'entity_id': pep_entry.id\n                            })\n            \n            return matches\n            \n        except Exception as e:\n            logger.error(f\"Error screening against PEPs: {e}\")\n            return []\n    \n    def calculate_similarity(self, name1: str, name2: str) -> float:\n        \"\"\"Calculate similarity between two names using multiple techniques\"\"\"\n        try:\n            if not name1 or not name2:\n                return 0.0\n            \n            # Normalize names\n            norm_name1 = self.normalize_name(name1)\n            norm_name2 = self.normalize_name(name2)\n            \n            # Exact match\n            if norm_name1 == norm_name2:\n                return 1.0\n            \n            # Token-based similarity\n            token_similarity = self.calculate_token_similarity(norm_name1, norm_name2)\n            \n            # Sequence-based similarity\n            sequence_similarity = SequenceMatcher(None, norm_name1, norm_name2).ratio()\n            \n            # Phonetic similarity\n            phonetic_similarity = self.calculate_phonetic_similarity(norm_name1, norm_name2)\n            \n            # Weighted combination\n            final_similarity = (\n                token_similarity * 0.4 +\n                sequence_similarity * 0.4 +\n                phonetic_similarity * 0.2\n            )\n            \n            return final_similarity\n            \n        except Exception as e:\n            logger.error(f\"Error calculating similarity: {e}\")\n            return 0.0\n    \n    def normalize_name(self, name: str) -> str:\n        \"\"\"Normalize name for comparison\"\"\"\n        try:\n            # Convert to uppercase\n            normalized = name.upper().strip()\n            \n            # Remove special characters\n            normalized = re.sub(r'[^\\w\\s]', ' ', normalized)\n            \n            # Replace multiple spaces with single space\n            normalized = re.sub(r'\\s+', ' ', normalized)\n            \n            # Apply name variations\n            for full_form, abbreviations in self.name_variations.items():\n                for abbrev in abbreviations:\n                    normalized = re.sub(r'\\b' + re.escape(abbrev) + r'\\b', full_form, normalized)\n            \n            return normalized.strip()\n            \n        except Exception as e:\n            logger.error(f\"Error normalizing name: {e}\")\n            return name.upper()\n    \n    def calculate_token_similarity(self, name1: str, name2: str) -> float:\n        \"\"\"Calculate token-based similarity\"\"\"\n        try:\n            tokens1 = set(name1.split())\n            tokens2 = set(name2.split())\n            \n            if not tokens1 or not tokens2:\n                return 0.0\n            \n            # Jaccard similarity\n            intersection = len(tokens1.intersection(tokens2))\n            union = len(tokens1.union(tokens2))\n            \n            return intersection / union if union > 0 else 0.0\n            \n        except Exception as e:\n            logger.error(f\"Error calculating token similarity: {e}\")\n            return 0.0\n    \n    def calculate_phonetic_similarity(self, name1: str, name2: str) -> float:\n        \"\"\"Calculate phonetic similarity using simple transliteration\"\"\"\n        try:\n            # Apply transliterations\n            phonetic1 = name1\n            phonetic2 = name2\n            \n            for original, replacement in self.transliterations.items():\n                phonetic1 = phonetic1.replace(original, replacement)\n                phonetic2 = phonetic2.replace(original, replacement)\n            \n            # Calculate similarity on phonetic versions\n            return SequenceMatcher(None, phonetic1, phonetic2).ratio()\n            \n        except Exception as e:\n            logger.error(f\"Error calculating phonetic similarity: {e}\")\n            return 0.0\n    \n    def compare_dates(self, date1, date2) -> bool:\n        \"\"\"Compare dates allowing for minor variations\"\"\"\n        try:\n            if not date1 or not date2:\n                return False\n            \n            # Convert to strings for comparison\n            date1_str = str(date1) if hasattr(date1, 'strftime') else str(date1)\n            date2_str = str(date2) if hasattr(date2, 'strftime') else str(date2)\n            \n            # Extract year from both dates\n            year1 = re.search(r'\\b(19|20)\\d{2}\\b', date1_str)\n            year2 = re.search(r'\\b(19|20)\\d{2}\\b', date2_str)\n            \n            if year1 and year2:\n                return abs(int(year1.group()) - int(year2.group())) <= 1  # Allow 1 year difference\n            \n            return False\n            \n        except Exception as e:\n            logger.error(f\"Error comparing dates: {e}\")\n            return False\n    \n    async def update_sanctions_lists(self, db: Session) -> bool:\n        \"\"\"Update sanctions lists from external sources\"\"\"\n        try:\n            # In production, this would connect to OFAC, UN, EU APIs\n            # For now, we'll create some sample entries\n            \n            sample_sanctions = [\n                {\n                    'list_name': 'OFAC_SDN',\n                    'entity_name': 'BLOCKED PERSON ONE',\n                    'entity_type': 'INDIVIDUAL',\n                    'program': 'TERRORISM',\n                    'aliases': ['BLOCKED ALIAS ONE', 'B.P. ONE']\n                },\n                {\n                    'list_name': 'UN_SANCTIONS',\n                    'entity_name': 'SANCTIONED COMPANY LTD',\n                    'entity_type': 'ENTITY',\n                    'program': 'PROLIFERATION',\n                    'aliases': ['SANCTIONED CO', 'SANCTIONED CORP']\n                }\n            ]\n            \n            for entry in sample_sanctions:\n                existing = db.query(SanctionsList).filter(\n                    SanctionsList.entity_name == entry['entity_name']\n                ).first()\n                \n                if not existing:\n                    sanctions_entry = SanctionsList(**entry)\n                    db.add(sanctions_entry)\n            \n            db.commit()\n            logger.info(\"Sanctions lists updated successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error updating sanctions lists: {e}\")\n            db.rollback()\n            return False\n    \n    async def update_pep_lists(self, db: Session) -> bool:\n        \"\"\"Update PEP lists from external sources\"\"\"\n        try:\n            # Sample PEP entries\n            sample_peps = [\n                {\n                    'full_name': 'JOHN POLITICAL LEADER',\n                    'position': 'MINISTER OF FINANCE',\n                    'country': 'ZIMBABWE',\n                    'category': 'MINISTER',\n                    'is_active': True,\n                    'aliases': ['J. POLITICAL LEADER', 'MINISTER JOHN']\n                },\n                {\n                    'full_name': 'JANE HEAD OF STATE',\n                    'position': 'PRESIDENT',\n                    'country': 'SOUTH AFRICA',\n                    'category': 'HEAD_OF_STATE',\n                    'is_active': True,\n                    'aliases': ['PRESIDENT JANE', 'J. HEAD OF STATE']\n                }\n            ]\n            \n            for entry in sample_peps:\n                existing = db.query(PEPList).filter(\n                    PEPList.full_name == entry['full_name']\n                ).first()\n                \n                if not existing:\n                    pep_entry = PEPList(**entry)\n                    db.add(pep_entry)\n            \n            db.commit()\n            logger.info(\"PEP lists updated successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error updating PEP lists: {e}\")\n            db.rollback()\n            return False\n","size_bytes":17581},"utils.py":{"content":"\"\"\"\nUtility functions for the AML Transaction Monitoring System\n\"\"\"\n\nimport logging\nimport hashlib\nimport re\nimport uuid\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, func, desc\n\nfrom models import Transaction, Customer, Alert\n\nlogger = logging.getLogger(__name__)\n\ndef generate_transaction_id() -> str:\n    \"\"\"Generate unique transaction ID\"\"\"\n    return f\"TXN-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:8].upper()}\"\n\ndef generate_alert_id() -> str:\n    \"\"\"Generate unique alert ID\"\"\"\n    return f\"ALT-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:8].upper()}\"\n\ndef hash_sensitive_data(data: str) -> str:\n    \"\"\"Hash sensitive data for storage\"\"\"\n    if not data:\n        return \"\"\n    return hashlib.sha256(data.encode()).hexdigest()\n\ndef mask_account_number(account_number: str) -> str:\n    \"\"\"Mask account number for display\"\"\"\n    if not account_number or len(account_number) < 4:\n        return account_number\n    return \"*\" * (len(account_number) - 4) + account_number[-4:]\n\ndef mask_id_number(id_number: str) -> str:\n    \"\"\"Mask ID number for display\"\"\"\n    if not id_number or len(id_number) < 4:\n        return id_number\n    return id_number[:2] + \"*\" * (len(id_number) - 4) + id_number[-2:]\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate email address format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef validate_phone_number(phone: str) -> bool:\n    \"\"\"Validate phone number format\"\"\"\n    # Remove all non-digit characters\n    digits_only = re.sub(r'\\D', '', phone)\n    # Check if it's between 7 and 15 digits\n    return 7 <= len(digits_only) <= 15\n\ndef standardize_name(name: str) -> str:\n    \"\"\"Standardize name for comparison\"\"\"\n    if not name:\n        return \"\"\n    \n    # Convert to uppercase and remove extra spaces\n    standardized = ' '.join(name.upper().split())\n    \n    # Remove common prefixes and suffixes\n    prefixes = ['MR', 'MRS', 'MS', 'DR', 'PROF', 'REV']\n    suffixes = ['JR', 'SR', 'III', 'IV', 'PhD', 'MD']\n    \n    words = standardized.split()\n    \n    # Remove prefixes\n    if words and words[0] in prefixes:\n        words = words[1:]\n    \n    # Remove suffixes\n    if words and words[-1] in suffixes:\n        words = words[:-1]\n    \n    return ' '.join(words)\n\ndef calculate_age(date_of_birth: datetime) -> int:\n    \"\"\"Calculate age from date of birth\"\"\"\n    if not date_of_birth:\n        return 0\n    \n    today = datetime.now()\n    age = today.year - date_of_birth.year\n    \n    # Adjust if birthday hasn't occurred this year\n    if today.month < date_of_birth.month or (today.month == date_of_birth.month and today.day < date_of_birth.day):\n        age -= 1\n    \n    return age\n\ndef format_currency(amount: float, currency: str = \"USD\") -> str:\n    \"\"\"Format currency amount for display\"\"\"\n    currency_symbols = {\n        'USD': '$',\n        'ZWL': 'Z$',\n        'ZAR': 'R',\n        'EUR': '€',\n        'GBP': '£',\n        'JPY': '¥',\n        'CNY': '¥',\n        'AUD': 'A$',\n        'CAD': 'C$',\n        'CHF': 'Fr'\n    }\n    \n    symbol = currency_symbols.get(currency, currency)\n    \n    if currency in ['JPY']:\n        return f\"{symbol}{amount:,.0f}\"\n    else:\n        return f\"{symbol}{amount:,.2f}\"\n\ndef parse_amount(amount_str: str) -> Optional[float]:\n    \"\"\"Parse amount string to float\"\"\"\n    if not amount_str:\n        return None\n    \n    # Remove currency symbols and spaces\n    cleaned = re.sub(r'[^\\d.,\\-]', '', str(amount_str))\n    \n    try:\n        # Handle different decimal separators\n        if ',' in cleaned and '.' in cleaned:\n            # Assume comma is thousands separator\n            cleaned = cleaned.replace(',', '')\n        elif ',' in cleaned:\n            # Could be decimal separator (European style)\n            parts = cleaned.split(',')\n            if len(parts) == 2 and len(parts[1]) <= 2:\n                cleaned = cleaned.replace(',', '.')\n        \n        return float(cleaned)\n    except (ValueError, TypeError):\n        logger.error(f\"Could not parse amount: {amount_str}\")\n        return None\n\ndef calculate_transaction_velocity(customer_id: str, hours: int, db: Session) -> float:\n    \"\"\"Calculate transaction velocity for a customer\"\"\"\n    try:\n        start_time = datetime.now() - timedelta(hours=hours)\n        \n        transaction_count = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.created_at >= start_time\n            )\n        ).count()\n        \n        return transaction_count / hours\n        \n    except Exception as e:\n        logger.error(f\"Error calculating transaction velocity: {e}\")\n        return 0.0\n\ndef get_customer_transaction_history(customer_id: str, days: int, db: Session) -> List[Transaction]:\n    \"\"\"Get customer transaction history\"\"\"\n    try:\n        start_date = datetime.now() - timedelta(days=days)\n        \n        transactions = db.query(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Transaction.created_at >= start_date\n            )\n        ).order_by(desc(Transaction.created_at)).all()\n        \n        return transactions\n        \n    except Exception as e:\n        logger.error(f\"Error getting customer transaction history: {e}\")\n        return []\n\ndef calculate_customer_risk_factors(customer_id: str, db: Session) -> Dict[str, Any]:\n    \"\"\"Calculate various risk factors for a customer\"\"\"\n    try:\n        customer = db.query(Customer).filter(Customer.customer_id == customer_id).first()\n        if not customer:\n            return {}\n        \n        # Recent transaction analysis\n        recent_transactions = get_customer_transaction_history(customer_id, 30, db)\n        \n        # Calculate metrics\n        total_volume = sum(t.base_amount for t in recent_transactions)\n        avg_transaction = total_volume / len(recent_transactions) if recent_transactions else 0\n        max_transaction = max(t.base_amount for t in recent_transactions) if recent_transactions else 0\n        \n        # Velocity metrics\n        velocity_24h = calculate_transaction_velocity(customer_id, 24, db)\n        velocity_7d = calculate_transaction_velocity(customer_id, 168, db)  # 7 days in hours\n        \n        # Channel diversity\n        channels_used = set(t.channel for t in recent_transactions)\n        channel_diversity = len(channels_used)\n        \n        # Time pattern analysis\n        transaction_hours = [t.created_at.hour for t in recent_transactions]\n        unusual_hours = sum(1 for hour in transaction_hours if hour < 6 or hour > 22)\n        unusual_hours_ratio = unusual_hours / len(transaction_hours) if transaction_hours else 0\n        \n        # Recent alerts\n        recent_alerts = db.query(Alert).join(Transaction).filter(\n            and_(\n                Transaction.customer_id == customer_id,\n                Alert.created_at >= datetime.now() - timedelta(days=30)\n            )\n        ).count()\n        \n        # Customer age (days since account opening)\n        account_age_days = 0\n        if customer.account_opening_date:\n            account_age_days = (datetime.now() - customer.account_opening_date).days\n        \n        return {\n            'total_volume_30d': total_volume,\n            'transaction_count_30d': len(recent_transactions),\n            'avg_transaction_amount': avg_transaction,\n            'max_transaction_amount': max_transaction,\n            'velocity_24h': velocity_24h,\n            'velocity_7d': velocity_7d,\n            'channel_diversity': channel_diversity,\n            'unusual_hours_ratio': unusual_hours_ratio,\n            'recent_alerts_count': recent_alerts,\n            'account_age_days': account_age_days,\n            'is_pep': customer.is_pep,\n            'risk_rating': customer.risk_rating.value if customer.risk_rating else 'LOW'\n        }\n        \n    except Exception as e:\n        logger.error(f\"Error calculating customer risk factors: {e}\")\n        return {}\n\ndef extract_transaction_features(transaction_data: Dict[str, Any]) -> Dict[str, float]:\n    \"\"\"Extract numerical features from transaction data for ML models\"\"\"\n    try:\n        features = {}\n        \n        # Basic transaction features\n        features['amount'] = float(transaction_data.get('base_amount', 0))\n        features['amount_log'] = float(np.log1p(features['amount']))\n        \n        # Time-based features\n        timestamp = transaction_data.get('timestamp', datetime.now())\n        if isinstance(timestamp, str):\n            timestamp = datetime.fromisoformat(timestamp)\n        \n        features['hour'] = float(timestamp.hour)\n        features['day_of_week'] = float(timestamp.weekday())\n        features['day_of_month'] = float(timestamp.day)\n        features['month'] = float(timestamp.month)\n        features['is_weekend'] = float(timestamp.weekday() >= 5)\n        features['is_business_hours'] = float(9 <= timestamp.hour <= 17)\n        \n        # Channel encoding\n        channel = transaction_data.get('channel', '').upper()\n        channel_mapping = {\n            'INTERNAL': 1, 'ATM': 2, 'POS': 3, 'MOBILE': 4,\n            'INTERNET': 5, 'BRANCH': 6, 'RTGS': 7, 'SWIFT': 8, 'ZIPIT': 9\n        }\n        features['channel_encoded'] = float(channel_mapping.get(channel, 0))\n        \n        # Transaction type encoding\n        txn_type = transaction_data.get('transaction_type', '').upper()\n        type_mapping = {'CREDIT': 1, 'DEBIT': 2, 'TRANSFER': 3}\n        features['transaction_type_encoded'] = float(type_mapping.get(txn_type, 0))\n        \n        # Currency encoding\n        currency = transaction_data.get('currency', 'USD')\n        currency_mapping = {\n            'USD': 1, 'ZWL': 2, 'ZAR': 3, 'EUR': 4, 'GBP': 5,\n            'JPY': 6, 'CNY': 7, 'AUD': 8, 'CAD': 9, 'CHF': 10\n        }\n        features['currency_encoded'] = float(currency_mapping.get(currency, 0))\n        \n        # Cross-border indicator\n        features['is_cross_border'] = float(bool(transaction_data.get('counterparty_country')))\n        \n        # High-value indicator\n        features['is_high_value'] = float(features['amount'] > 10000)\n        \n        return features\n        \n    except Exception as e:\n        logger.error(f\"Error extracting transaction features: {e}\")\n        return {}\n\ndef calculate_similarity_score(text1: str, text2: str) -> float:\n    \"\"\"Calculate similarity score between two text strings\"\"\"\n    if not text1 or not text2:\n        return 0.0\n    \n    # Simple Levenshtein distance-based similarity\n    def levenshtein_distance(s1, s2):\n        if len(s1) < len(s2):\n            return levenshtein_distance(s2, s1)\n        \n        if len(s2) == 0:\n            return len(s1)\n        \n        previous_row = range(len(s2) + 1)\n        for i, c1 in enumerate(s1):\n            current_row = [i + 1]\n            for j, c2 in enumerate(s2):\n                insertions = previous_row[j + 1] + 1\n                deletions = current_row[j] + 1\n                substitutions = previous_row[j] + (c1 != c2)\n                current_row.append(min(insertions, deletions, substitutions))\n            previous_row = current_row\n        \n        return previous_row[-1]\n    \n    text1 = text1.upper().strip()\n    text2 = text2.upper().strip()\n    \n    max_len = max(len(text1), len(text2))\n    if max_len == 0:\n        return 1.0\n    \n    distance = levenshtein_distance(text1, text2)\n    similarity = 1 - (distance / max_len)\n    \n    return max(0.0, similarity)\n\ndef validate_iban(iban: str) -> bool:\n    \"\"\"Validate IBAN format\"\"\"\n    if not iban:\n        return False\n    \n    # Remove spaces and convert to uppercase\n    iban = iban.replace(' ', '').upper()\n    \n    # Check length (should be between 15 and 34 characters)\n    if not (15 <= len(iban) <= 34):\n        return False\n    \n    # Check if starts with two letters\n    if not iban[:2].isalpha():\n        return False\n    \n    # Check if next two characters are digits\n    if not iban[2:4].isdigit():\n        return False\n    \n    # Simple format validation (full IBAN validation requires country-specific rules)\n    return True\n\ndef validate_swift_code(swift_code: str) -> bool:\n    \"\"\"Validate SWIFT/BIC code format\"\"\"\n    if not swift_code:\n        return False\n    \n    swift_code = swift_code.upper().strip()\n    \n    # SWIFT codes are 8 or 11 characters\n    if len(swift_code) not in [8, 11]:\n        return False\n    \n    # First 4 characters should be letters (bank code)\n    if not swift_code[:4].isalpha():\n        return False\n    \n    # Next 2 characters should be letters (country code)\n    if not swift_code[4:6].isalpha():\n        return False\n    \n    # Next 2 characters should be alphanumeric (location code)\n    if not swift_code[6:8].isalnum():\n        return False\n    \n    # If 11 characters, last 3 should be alphanumeric (branch code)\n    if len(swift_code) == 11 and not swift_code[8:11].isalnum():\n        return False\n    \n    return True\n\ndef format_large_number(number: float) -> str:\n    \"\"\"Format large numbers with appropriate suffixes\"\"\"\n    if number >= 1_000_000_000:\n        return f\"{number / 1_000_000_000:.1f}B\"\n    elif number >= 1_000_000:\n        return f\"{number / 1_000_000:.1f}M\"\n    elif number >= 1_000:\n        return f\"{number / 1_000:.1f}K\"\n    else:\n        return f\"{number:.0f}\"\n\ndef get_business_days_between(start_date: datetime, end_date: datetime) -> int:\n    \"\"\"Calculate business days between two dates\"\"\"\n    business_days = 0\n    current_date = start_date\n    \n    while current_date <= end_date:\n        if current_date.weekday() < 5:  # Monday = 0, Sunday = 6\n            business_days += 1\n        current_date += timedelta(days=1)\n    \n    return business_days\n\ndef is_business_day(date: datetime) -> bool:\n    \"\"\"Check if a date is a business day\"\"\"\n    return date.weekday() < 5\n\ndef get_next_business_day(date: datetime) -> datetime:\n    \"\"\"Get the next business day\"\"\"\n    next_day = date + timedelta(days=1)\n    while next_day.weekday() >= 5:\n        next_day += timedelta(days=1)\n    return next_day\n\ndef sanitize_input(input_string: str) -> str:\n    \"\"\"Sanitize input string to prevent XSS\"\"\"\n    if not input_string:\n        return \"\"\n    \n    # Remove HTML tags\n    clean = re.sub(r'<[^>]+>', '', input_string)\n    \n    # Remove potential script injections\n    clean = re.sub(r'javascript:', '', clean, flags=re.IGNORECASE)\n    clean = re.sub(r'vbscript:', '', clean, flags=re.IGNORECASE)\n    clean = re.sub(r'on\\w+\\s*=', '', clean, flags=re.IGNORECASE)\n    \n    return clean.strip()\n\n# Import numpy for logarithmic calculations\ntry:\n    import numpy as np\nexcept ImportError:\n    # Fallback implementation if numpy is not available\n    import math\n    \n    class NumpyFallback:\n        @staticmethod\n        def log1p(x):\n            return math.log(1 + x)\n    \n    np = NumpyFallback()\n","size_bytes":15005},"static/css/banking-dashboard.css":{"content":"/* Banking AML Transaction Monitoring System - Professional Styling */\n\n:root {\n    /* Primary Banking Colors */\n    --primary-blue: #1e3a5f;\n    --primary-light: #2e4a6f;\n    --secondary-blue: #4a90e2;\n    --accent-gold: #d4af37;\n    \n    /* Status Colors */\n    --success-green: #28a745;\n    --warning-orange: #ffc107;\n    --danger-red: #dc3545;\n    --info-blue: #17a2b8;\n    \n    /* Neutral Colors */\n    --white: #ffffff;\n    --light-gray: #f8f9fa;\n    --medium-gray: #e9ecef;\n    --dark-gray: #6c757d;\n    --text-dark: #343a40;\n    \n    /* Shadows and Effects */\n    --shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);\n    --shadow-md: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);\n    --shadow-lg: 0 1rem 3rem rgba(0, 0, 0, 0.175);\n    \n    /* Typography */\n    --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    --font-size-sm: 0.875rem;\n    --font-size-base: 1rem;\n    --font-size-lg: 1.25rem;\n    --font-size-xl: 1.5rem;\n    \n    /* Layout */\n    --border-radius: 0.375rem;\n    --border-width: 1px;\n    --sidebar-width: 260px;\n    --header-height: 70px;\n}\n\n/* Global Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: var(--font-family);\n    font-size: var(--font-size-base);\n    line-height: 1.5;\n    color: var(--text-dark);\n    background-color: var(--light-gray);\n}\n\n/* Typography */\nh1, h2, h3, h4, h5, h6 {\n    font-weight: 600;\n    line-height: 1.2;\n    margin-bottom: 0.5rem;\n}\n\nh1 { font-size: 2rem; }\nh2 { font-size: 1.75rem; }\nh3 { font-size: 1.5rem; }\nh4 { font-size: 1.25rem; }\nh5 { font-size: 1.125rem; }\nh6 { font-size: 1rem; }\n\n/* Layout Structure */\n.app-container {\n    display: flex;\n    min-height: 100vh;\n}\n\n/* Sidebar */\n.sidebar {\n    width: var(--sidebar-width);\n    background: linear-gradient(180deg, var(--primary-blue) 0%, var(--primary-light) 100%);\n    color: var(--white);\n    box-shadow: var(--shadow-lg);\n    position: fixed;\n    height: 100vh;\n    overflow-y: auto;\n    z-index: 1000;\n}\n\n.sidebar-brand {\n    padding: 1.5rem 1rem;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    text-align: center;\n}\n\n.sidebar-brand h3 {\n    color: var(--accent-gold);\n    font-weight: 700;\n    margin-bottom: 0.25rem;\n}\n\n.sidebar-brand p {\n    font-size: var(--font-size-sm);\n    opacity: 0.8;\n    margin: 0;\n}\n\n.sidebar-nav {\n    list-style: none;\n    padding: 1rem 0;\n}\n\n.nav-item {\n    margin-bottom: 0.25rem;\n}\n\n.nav-link {\n    display: flex;\n    align-items: center;\n    padding: 0.75rem 1.5rem;\n    color: var(--white);\n    text-decoration: none;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    border-left: 3px solid transparent;\n}\n\n.nav-link:hover {\n    background-color: rgba(255, 255, 255, 0.1);\n    color: var(--accent-gold);\n    border-left-color: var(--accent-gold);\n}\n\n.nav-link.active {\n    background-color: rgba(255, 255, 255, 0.15);\n    color: var(--accent-gold);\n    border-left-color: var(--accent-gold);\n}\n\n.nav-icon {\n    width: 20px;\n    height: 20px;\n    margin-right: 0.75rem;\n    opacity: 0.8;\n}\n\n/* Main Content */\n.main-content {\n    flex: 1;\n    margin-left: var(--sidebar-width);\n    display: flex;\n    flex-direction: column;\n}\n\n/* Header */\n.header {\n    background: var(--white);\n    height: var(--header-height);\n    box-shadow: var(--shadow-sm);\n    display: flex;\n    align-items: center;\n    justify-content: between;\n    padding: 0 2rem;\n    position: sticky;\n    top: 0;\n    z-index: 999;\n}\n\n.header-title {\n    flex: 1;\n}\n\n.header-title h1 {\n    color: var(--primary-blue);\n    font-size: var(--font-size-xl);\n    margin: 0;\n}\n\n.header-actions {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n}\n\n.user-menu {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.5rem 1rem;\n    background-color: var(--light-gray);\n    border-radius: var(--border-radius);\n    cursor: pointer;\n    transition: background-color 0.3s ease;\n}\n\n.user-menu:hover {\n    background-color: var(--medium-gray);\n}\n\n.user-avatar {\n    width: 32px;\n    height: 32px;\n    background-color: var(--primary-blue);\n    color: var(--white);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: 600;\n}\n\n/* Content Area */\n.content {\n    padding: 2rem;\n    flex: 1;\n    overflow-y: auto;\n}\n\n/* Cards */\n.card {\n    background: var(--white);\n    border-radius: var(--border-radius);\n    box-shadow: var(--shadow-sm);\n    border: var(--border-width) solid var(--medium-gray);\n    overflow: hidden;\n    margin-bottom: 1.5rem;\n}\n\n.card-header {\n    background-color: var(--light-gray);\n    border-bottom: var(--border-width) solid var(--medium-gray);\n    padding: 1rem 1.5rem;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.card-title {\n    font-size: var(--font-size-lg);\n    font-weight: 600;\n    margin: 0;\n    color: var(--primary-blue);\n}\n\n.card-body {\n    padding: 1.5rem;\n}\n\n.card-footer {\n    background-color: var(--light-gray);\n    border-top: var(--border-width) solid var(--medium-gray);\n    padding: 1rem 1.5rem;\n}\n\n/* Metrics Cards */\n.metrics-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 1.5rem;\n    margin-bottom: 2rem;\n}\n\n.metric-card {\n    background: var(--white);\n    padding: 1.5rem;\n    border-radius: var(--border-radius);\n    box-shadow: var(--shadow-md);\n    text-align: center;\n    position: relative;\n    overflow: hidden;\n}\n\n.metric-card::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 4px;\n    background: linear-gradient(90deg, var(--secondary-blue), var(--accent-gold));\n}\n\n.metric-value {\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 0.5rem;\n}\n\n.metric-label {\n    font-size: var(--font-size-sm);\n    color: var(--dark-gray);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    font-weight: 600;\n}\n\n.metric-change {\n    margin-top: 0.5rem;\n    font-size: var(--font-size-sm);\n    font-weight: 600;\n}\n\n.change-positive {\n    color: var(--success-green);\n}\n\n.change-negative {\n    color: var(--danger-red);\n}\n\n/* Status Indicators */\n.status-badge {\n    display: inline-flex;\n    align-items: center;\n    padding: 0.25rem 0.75rem;\n    font-size: var(--font-size-sm);\n    font-weight: 600;\n    border-radius: 50px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.status-open { background-color: rgba(255, 193, 7, 0.15); color: #856404; }\n.status-investigating { background-color: rgba(23, 162, 184, 0.15); color: #0c5460; }\n.status-closed { background-color: rgba(40, 167, 69, 0.15); color: #155724; }\n.status-high { background-color: rgba(220, 53, 69, 0.15); color: #721c24; }\n.status-medium { background-color: rgba(255, 193, 7, 0.15); color: #856404; }\n.status-low { background-color: rgba(40, 167, 69, 0.15); color: #155724; }\n\n/* Risk Score Indicators */\n.risk-score {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    font-weight: 700;\n    font-size: var(--font-size-sm);\n}\n\n.risk-critical {\n    background-color: var(--danger-red);\n    color: var(--white);\n}\n\n.risk-high {\n    background-color: rgba(220, 53, 69, 0.8);\n    color: var(--white);\n}\n\n.risk-medium {\n    background-color: var(--warning-orange);\n    color: var(--text-dark);\n}\n\n.risk-low {\n    background-color: var(--success-green);\n    color: var(--white);\n}\n\n/* Buttons */\n.btn {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    padding: 0.5rem 1rem;\n    font-size: var(--font-size-base);\n    font-weight: 500;\n    text-align: center;\n    text-decoration: none;\n    border: var(--border-width) solid transparent;\n    border-radius: var(--border-radius);\n    cursor: pointer;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-primary {\n    background-color: var(--primary-blue);\n    border-color: var(--primary-blue);\n    color: var(--white);\n}\n\n.btn-primary:hover {\n    background-color: var(--primary-light);\n    border-color: var(--primary-light);\n}\n\n.btn-secondary {\n    background-color: var(--dark-gray);\n    border-color: var(--dark-gray);\n    color: var(--white);\n}\n\n.btn-success {\n    background-color: var(--success-green);\n    border-color: var(--success-green);\n    color: var(--white);\n}\n\n.btn-warning {\n    background-color: var(--warning-orange);\n    border-color: var(--warning-orange);\n    color: var(--text-dark);\n}\n\n.btn-danger {\n    background-color: var(--danger-red);\n    border-color: var(--danger-red);\n    color: var(--white);\n}\n\n.btn-outline-primary {\n    background-color: transparent;\n    border-color: var(--primary-blue);\n    color: var(--primary-blue);\n}\n\n.btn-outline-primary:hover {\n    background-color: var(--primary-blue);\n    color: var(--white);\n}\n\n.btn-sm {\n    padding: 0.375rem 0.75rem;\n    font-size: var(--font-size-sm);\n}\n\n.btn-lg {\n    padding: 0.75rem 1.5rem;\n    font-size: var(--font-size-lg);\n}\n\n/* Tables */\n.table-container {\n    overflow-x: auto;\n    border-radius: var(--border-radius);\n}\n\n.table {\n    width: 100%;\n    background-color: var(--white);\n    border-collapse: collapse;\n    border-spacing: 0;\n}\n\n.table th,\n.table td {\n    padding: 0.75rem 1rem;\n    text-align: left;\n    border-bottom: var(--border-width) solid var(--medium-gray);\n}\n\n.table th {\n    background-color: var(--light-gray);\n    font-weight: 600;\n    color: var(--primary-blue);\n    text-transform: uppercase;\n    font-size: var(--font-size-sm);\n    letter-spacing: 0.5px;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.table-striped tbody tr:nth-child(odd) {\n    background-color: rgba(0, 0, 0, 0.02);\n}\n\n.table-hover tbody tr:hover {\n    background-color: rgba(0, 0, 0, 0.05);\n    cursor: pointer;\n}\n\n/* Forms */\n.form-group {\n    margin-bottom: 1.5rem;\n}\n\n.form-label {\n    display: block;\n    margin-bottom: 0.5rem;\n    font-weight: 600;\n    color: var(--text-dark);\n}\n\n.form-control {\n    display: block;\n    width: 100%;\n    padding: 0.5rem 0.75rem;\n    font-size: var(--font-size-base);\n    border: var(--border-width) solid var(--medium-gray);\n    border-radius: var(--border-radius);\n    background-color: var(--white);\n    transition: border-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.form-control:focus {\n    outline: none;\n    border-color: var(--secondary-blue);\n    box-shadow: 0 0 0 0.25rem rgba(74, 144, 226, 0.25);\n}\n\n.form-select {\n    background-image: url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m1 6 7 7 7-7'/%3e%3c/svg%3e\");\n    background-repeat: no-repeat;\n    background-position: right 0.75rem center;\n    background-size: 16px 12px;\n    padding-right: 2.5rem;\n}\n\n/* Alerts */\n.alert {\n    padding: 1rem 1.5rem;\n    margin-bottom: 1rem;\n    border: var(--border-width) solid transparent;\n    border-radius: var(--border-radius);\n    position: relative;\n}\n\n.alert-success {\n    background-color: rgba(40, 167, 69, 0.1);\n    border-color: rgba(40, 167, 69, 0.3);\n    color: #155724;\n}\n\n.alert-warning {\n    background-color: rgba(255, 193, 7, 0.1);\n    border-color: rgba(255, 193, 7, 0.3);\n    color: #856404;\n}\n\n.alert-danger {\n    background-color: rgba(220, 53, 69, 0.1);\n    border-color: rgba(220, 53, 69, 0.3);\n    color: #721c24;\n}\n\n.alert-info {\n    background-color: rgba(23, 162, 184, 0.1);\n    border-color: rgba(23, 162, 184, 0.3);\n    color: #0c5460;\n}\n\n/* Modals */\n.modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.5);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 2000;\n}\n\n.modal {\n    background: var(--white);\n    border-radius: var(--border-radius);\n    box-shadow: var(--shadow-lg);\n    max-width: 90vw;\n    max-height: 90vh;\n    overflow: hidden;\n}\n\n.modal-header {\n    padding: 1.5rem;\n    border-bottom: var(--border-width) solid var(--medium-gray);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n}\n\n.modal-title {\n    margin: 0;\n    color: var(--primary-blue);\n}\n\n.modal-body {\n    padding: 1.5rem;\n    overflow-y: auto;\n}\n\n.modal-footer {\n    padding: 1rem 1.5rem;\n    border-top: var(--border-width) solid var(--medium-gray);\n    display: flex;\n    justify-content: flex-end;\n    gap: 0.5rem;\n}\n\n/* Loading States */\n.loading-spinner {\n    display: inline-block;\n    width: 20px;\n    height: 20px;\n    border: 3px solid rgba(0, 0, 0, 0.1);\n    border-radius: 50%;\n    border-top-color: var(--primary-blue);\n    animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n/* Charts */\n.chart-container {\n    position: relative;\n    height: 300px;\n    margin: 1rem 0;\n}\n\n/* Real-time Status */\n.realtime-indicator {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.25rem 0.75rem;\n    background-color: var(--success-green);\n    color: var(--white);\n    border-radius: 50px;\n    font-size: var(--font-size-sm);\n    font-weight: 600;\n}\n\n.realtime-dot {\n    width: 8px;\n    height: 8px;\n    background-color: var(--white);\n    border-radius: 50%;\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0% { opacity: 1; }\n    50% { opacity: 0.5; }\n    100% { opacity: 1; }\n}\n\n/* Transaction Flow */\n.transaction-flow {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    padding: 1rem;\n    background-color: var(--light-gray);\n    border-radius: var(--border-radius);\n    margin: 1rem 0;\n}\n\n.flow-step {\n    flex: 1;\n    text-align: center;\n    position: relative;\n}\n\n.flow-step:not(:last-child)::after {\n    content: '→';\n    position: absolute;\n    right: -0.5rem;\n    top: 50%;\n    transform: translateY(-50%);\n    color: var(--primary-blue);\n    font-weight: bold;\n}\n\n.flow-icon {\n    width: 40px;\n    height: 40px;\n    background-color: var(--primary-blue);\n    color: var(--white);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 0 auto 0.5rem;\n}\n\n/* Responsive Design */\n@media (max-width: 1200px) {\n    .metrics-grid {\n        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    }\n}\n\n@media (max-width: 768px) {\n    :root {\n        --sidebar-width: 0px;\n    }\n    \n    .sidebar {\n        transform: translateX(-100%);\n        transition: transform 0.3s ease;\n    }\n    \n    .sidebar.show {\n        transform: translateX(0);\n    }\n    \n    .main-content {\n        margin-left: 0;\n    }\n    \n    .header {\n        padding: 0 1rem;\n    }\n    \n    .content {\n        padding: 1rem;\n    }\n    \n    .metrics-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .table-container {\n        font-size: var(--font-size-sm);\n    }\n    \n    .modal {\n        margin: 1rem;\n        max-width: calc(100% - 2rem);\n    }\n}\n\n@media (max-width: 480px) {\n    .header-actions {\n        flex-direction: column;\n        gap: 0.5rem;\n    }\n    \n    .card-header {\n        flex-direction: column;\n        align-items: flex-start;\n        gap: 0.5rem;\n    }\n    \n    .btn {\n        font-size: var(--font-size-sm);\n        padding: 0.375rem 0.75rem;\n    }\n}\n\n/* Print Styles */\n@media print {\n    .sidebar,\n    .header-actions,\n    .btn {\n        display: none !important;\n    }\n    \n    .main-content {\n        margin-left: 0 !important;\n    }\n    \n    .content {\n        padding: 0 !important;\n    }\n    \n    .card {\n        box-shadow: none !important;\n        border: 1px solid #000 !important;\n        margin-bottom: 1rem !important;\n    }\n}\n\n/* Accessibility */\n@media (prefers-reduced-motion: reduce) {\n    * {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n    }\n}\n\n/* High Contrast Mode */\n@media (prefers-contrast: high) {\n    :root {\n        --primary-blue: #000080;\n        --text-dark: #000000;\n        --medium-gray: #808080;\n    }\n}\n\n/* Focus States for Accessibility */\n.btn:focus,\n.form-control:focus,\n.nav-link:focus {\n    outline: 2px solid var(--secondary-blue);\n    outline-offset: 2px;\n}\n","size_bytes":16183},"static/js/admin-panel.js":{"content":"/**\n * AML Admin Panel - Administrative Interface\n * System configuration, user management, and monitoring controls\n */\n\nclass AMLAdminPanel {\n    constructor() {\n        this.config = {\n            refreshInterval: 60000, // 1 minute\n            maxLogEntries: 1000\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * Initialize admin panel\n     */\n    async init() {\n        console.log('Initializing AML Admin Panel...');\n        \n        try {\n            await this.loadSystemStatus();\n            await this.loadSystemConfiguration();\n            await this.setupEventListeners();\n            await this.startSystemMonitoring();\n            \n            console.log('Admin panel initialized successfully');\n        } catch (error) {\n            console.error('Error initializing admin panel:', error);\n            this.showError('Failed to initialize admin panel');\n        }\n    }\n    \n    /**\n     * Load system status and metrics\n     */\n    async loadSystemStatus() {\n        try {\n            const response = await fetch('/api/admin/system-status');\n            if (!response.ok) throw new Error('Failed to load system status');\n            \n            const status = await response.json();\n            this.updateSystemStatus(status);\n            \n        } catch (error) {\n            console.error('Error loading system status:', error);\n            this.showError('Failed to load system status');\n        }\n    }\n    \n    /**\n     * Update system status display\n     */\n    updateSystemStatus(status) {\n        // Update system health indicators\n        this.updateHealthIndicator('database', status.database_status);\n        this.updateHealthIndicator('ml-engine', status.ml_engine_status);\n        this.updateHealthIndicator('websocket', status.websocket_status);\n        this.updateHealthIndicator('email-service', status.email_service_status);\n        \n        // Update system metrics\n        this.updateMetric('cpu-usage', status.cpu_usage, '%');\n        this.updateMetric('memory-usage', status.memory_usage, '%');\n        this.updateMetric('disk-usage', status.disk_usage, '%');\n        this.updateMetric('active-connections', status.active_connections);\n        \n        // Update processing stats\n        this.updateMetric('transactions-processed', status.transactions_processed_today);\n        this.updateMetric('alerts-generated', status.alerts_generated_today);\n        this.updateMetric('cases-opened', status.cases_opened_today);\n        this.updateMetric('ml-predictions', status.ml_predictions_today);\n    }\n    \n    /**\n     * Update health indicator\n     */\n    updateHealthIndicator(component, status) {\n        const indicator = document.getElementById(`${component}-status`);\n        if (!indicator) return;\n        \n        indicator.className = `health-indicator ${status.toLowerCase()}`;\n        indicator.innerHTML = `\n            <div class=\"status-dot status-${status.toLowerCase()}\"></div>\n            <span class=\"status-text\">${status}</span>\n        `;\n    }\n    \n    /**\n     * Update metric display\n     */\n    updateMetric(metricId, value, unit = '') {\n        const element = document.getElementById(metricId);\n        if (!element) return;\n        \n        const valueElement = element.querySelector('.metric-value');\n        if (valueElement) {\n            valueElement.textContent = value + unit;\n        }\n    }\n    \n    /**\n     * Load system configuration\n     */\n    async loadSystemConfiguration() {\n        try {\n            const response = await fetch('/api/admin/configuration');\n            if (!response.ok) throw new Error('Failed to load configuration');\n            \n            const config = await response.json();\n            this.populateConfigurationForm(config);\n            \n        } catch (error) {\n            console.error('Error loading configuration:', error);\n            this.showError('Failed to load system configuration');\n        }\n    }\n    \n    /**\n     * Populate configuration form\n     */\n    populateConfigurationForm(config) {\n        // Risk thresholds\n        this.setFormValue('risk-threshold-low', config.risk_threshold_low);\n        this.setFormValue('risk-threshold-medium', config.risk_threshold_medium);\n        this.setFormValue('risk-threshold-high', config.risk_threshold_high);\n        \n        // Alert settings\n        this.setFormValue('email-notifications', config.email_notifications_enabled);\n        this.setFormValue('sms-notifications', config.sms_notifications_enabled);\n        this.setFormValue('alert-retention-days', config.alert_retention_days);\n        \n        // ML settings\n        this.setFormValue('ml-enabled', config.ml_scoring_enabled);\n        this.setFormValue('anomaly-threshold', config.anomaly_threshold);\n        this.setFormValue('model-retrain-interval', config.model_retrain_interval_days);\n        \n        // Transaction limits\n        Object.keys(config.transaction_limits || {}).forEach(currency => {\n            const limits = config.transaction_limits[currency];\n            this.setFormValue(`limit-${currency.toLowerCase()}-low`, limits.low_risk);\n            this.setFormValue(`limit-${currency.toLowerCase()}-medium`, limits.medium_risk);\n            this.setFormValue(`limit-${currency.toLowerCase()}-high`, limits.high_risk);\n        });\n    }\n    \n    /**\n     * Set form field value\n     */\n    setFormValue(fieldId, value) {\n        const field = document.getElementById(fieldId);\n        if (!field) return;\n        \n        if (field.type === 'checkbox') {\n            field.checked = value;\n        } else {\n            field.value = value;\n        }\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    async setupEventListeners() {\n        // Configuration form submission\n        const configForm = document.getElementById('configurationForm');\n        if (configForm) {\n            configForm.addEventListener('submit', (e) => this.handleConfigurationSubmit(e));\n        }\n        \n        // User management buttons\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('create-user-btn')) {\n                this.showCreateUserModal();\n            }\n            \n            if (e.target.classList.contains('edit-user-btn')) {\n                const userId = e.target.dataset.userId;\n                this.showEditUserModal(userId);\n            }\n            \n            if (e.target.classList.contains('delete-user-btn')) {\n                const userId = e.target.dataset.userId;\n                this.confirmDeleteUser(userId);\n            }\n            \n            if (e.target.classList.contains('view-audit-btn')) {\n                const userId = e.target.dataset.userId;\n                this.showUserAuditLog(userId);\n            }\n        });\n        \n        // System actions\n        const restartBtn = document.getElementById('restartSystem');\n        if (restartBtn) {\n            restartBtn.addEventListener('click', () => this.confirmSystemRestart());\n        }\n        \n        const backupBtn = document.getElementById('createBackup');\n        if (backupBtn) {\n            backupBtn.addEventListener('click', () => this.createSystemBackup());\n        }\n        \n        const updateModelsBtn = document.getElementById('updateModels');\n        if (updateModelsBtn) {\n            updateModelsBtn.addEventListener('click', () => this.updateMLModels());\n        }\n        \n        const exportLogsBtn = document.getElementById('exportLogs');\n        if (exportLogsBtn) {\n            exportLogsBtn.addEventListener('click', () => this.exportSystemLogs());\n        }\n        \n        // Sanctions list management\n        const updateSanctionsBtn = document.getElementById('updateSanctions');\n        if (updateSanctionsBtn) {\n            updateSanctionsBtn.addEventListener('click', () => this.updateSanctionsLists());\n        }\n        \n        const uploadSanctionsBtn = document.getElementById('uploadSanctions');\n        if (uploadSanctionsBtn) {\n            uploadSanctionsBtn.addEventListener('click', () => this.showUploadSanctionsModal());\n        }\n    }\n    \n    /**\n     * Handle configuration form submission\n     */\n    async handleConfigurationSubmit(e) {\n        e.preventDefault();\n        \n        try {\n            const formData = new FormData(e.target);\n            const config = {};\n            \n            // Convert form data to configuration object\n            for (let [key, value] of formData.entries()) {\n                if (value === 'on') {\n                    config[key] = true;\n                } else if (value === 'off' || value === '') {\n                    config[key] = false;\n                } else if (!isNaN(value) && value !== '') {\n                    config[key] = parseFloat(value);\n                } else {\n                    config[key] = value;\n                }\n            }\n            \n            const response = await fetch('/api/admin/configuration', {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(config)\n            });\n            \n            if (!response.ok) throw new Error('Failed to update configuration');\n            \n            this.showSuccess('Configuration updated successfully');\n            \n        } catch (error) {\n            console.error('Error updating configuration:', error);\n            this.showError('Failed to update configuration');\n        }\n    }\n    \n    /**\n     * Show create user modal\n     */\n    showCreateUserModal() {\n        const modal = this.createUserModal();\n        document.body.appendChild(modal);\n        \n        if (typeof bootstrap !== 'undefined') {\n            new bootstrap.Modal(modal).show();\n        }\n    }\n    \n    /**\n     * Create user management modal\n     */\n    createUserModal(userData = null) {\n        const isEdit = userData !== null;\n        const modal = document.createElement('div');\n        modal.className = 'modal fade';\n        modal.innerHTML = `\n            <div class=\"modal-dialog\">\n                <div class=\"modal-content\">\n                    <div class=\"modal-header\">\n                        <h5 class=\"modal-title\">${isEdit ? 'Edit' : 'Create'} User</h5>\n                        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                    </div>\n                    <form id=\"userForm\">\n                        <div class=\"modal-body\">\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Username</label>\n                                <input type=\"text\" class=\"form-control\" name=\"username\" required \n                                       value=\"${userData?.username || ''}\" ${isEdit ? 'readonly' : ''}>\n                            </div>\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Full Name</label>\n                                <input type=\"text\" class=\"form-control\" name=\"full_name\" required \n                                       value=\"${userData?.full_name || ''}\">\n                            </div>\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Email</label>\n                                <input type=\"email\" class=\"form-control\" name=\"email\" required \n                                       value=\"${userData?.email || ''}\">\n                            </div>\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Role</label>\n                                <select class=\"form-control\" name=\"role\" required>\n                                    <option value=\"compliance_officer\" ${userData?.role === 'compliance_officer' ? 'selected' : ''}>Compliance Officer</option>\n                                    <option value=\"aml_analyst\" ${userData?.role === 'aml_analyst' ? 'selected' : ''}>AML Analyst</option>\n                                    <option value=\"supervisor\" ${userData?.role === 'supervisor' ? 'selected' : ''}>Supervisor</option>\n                                    <option value=\"admin\" ${userData?.role === 'admin' ? 'selected' : ''}>Administrator</option>\n                                </select>\n                            </div>\n                            ${!isEdit ? `\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Password</label>\n                                <input type=\"password\" class=\"form-control\" name=\"password\" required>\n                            </div>\n                            <div class=\"mb-3\">\n                                <label class=\"form-label\">Confirm Password</label>\n                                <input type=\"password\" class=\"form-control\" name=\"confirm_password\" required>\n                            </div>\n                            ` : ''}\n                            <div class=\"mb-3\">\n                                <div class=\"form-check\">\n                                    <input class=\"form-check-input\" type=\"checkbox\" name=\"is_active\" \n                                           ${userData?.is_active !== false ? 'checked' : ''}>\n                                    <label class=\"form-check-label\">Active</label>\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cancel</button>\n                            <button type=\"submit\" class=\"btn btn-primary\">${isEdit ? 'Update' : 'Create'} User</button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n        `;\n        \n        // Add form submission handler\n        const form = modal.querySelector('#userForm');\n        form.addEventListener('submit', (e) => {\n            e.preventDefault();\n            if (isEdit) {\n                this.updateUser(userData.id, new FormData(form));\n            } else {\n                this.createUser(new FormData(form));\n            }\n        });\n        \n        return modal;\n    }\n    \n    /**\n     * Create new user\n     */\n    async createUser(formData) {\n        try {\n            const userData = {};\n            for (let [key, value] of formData.entries()) {\n                userData[key] = value;\n            }\n            \n            // Validate passwords match\n            if (userData.password !== userData.confirm_password) {\n                this.showError('Passwords do not match');\n                return;\n            }\n            \n            delete userData.confirm_password;\n            \n            const response = await fetch('/api/admin/users', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(userData)\n            });\n            \n            if (!response.ok) throw new Error('Failed to create user');\n            \n            this.showSuccess('User created successfully');\n            this.loadUsers();\n            \n            // Close modal\n            const modal = document.querySelector('.modal.show');\n            if (modal && typeof bootstrap !== 'undefined') {\n                bootstrap.Modal.getInstance(modal).hide();\n            }\n            \n        } catch (error) {\n            console.error('Error creating user:', error);\n            this.showError('Failed to create user');\n        }\n    }\n    \n    /**\n     * Update ML models\n     */\n    async updateMLModels() {\n        try {\n            this.showLoading('Updating ML models...');\n            \n            const response = await fetch('/api/admin/ml-models/retrain', {\n                method: 'POST'\n            });\n            \n            if (!response.ok) throw new Error('Failed to update ML models');\n            \n            const result = await response.json();\n            this.showSuccess('ML models updated successfully');\n            \n        } catch (error) {\n            console.error('Error updating ML models:', error);\n            this.showError('Failed to update ML models');\n        } finally {\n            this.hideLoading();\n        }\n    }\n    \n    /**\n     * Update sanctions lists\n     */\n    async updateSanctionsLists() {\n        try {\n            this.showLoading('Updating sanctions lists...');\n            \n            const response = await fetch('/api/admin/sanctions/update', {\n                method: 'POST'\n            });\n            \n            if (!response.ok) throw new Error('Failed to update sanctions lists');\n            \n            const result = await response.json();\n            this.showSuccess(`Updated ${result.updated_entries} sanctions entries`);\n            \n        } catch (error) {\n            console.error('Error updating sanctions lists:', error);\n            this.showError('Failed to update sanctions lists');\n        } finally {\n            this.hideLoading();\n        }\n    }\n    \n    /**\n     * Create system backup\n     */\n    async createSystemBackup() {\n        try {\n            this.showLoading('Creating system backup...');\n            \n            const response = await fetch('/api/admin/backup', {\n                method: 'POST'\n            });\n            \n            if (!response.ok) throw new Error('Failed to create backup');\n            \n            // Download the backup file\n            const blob = await response.blob();\n            const url = window.URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `aml_backup_${new Date().toISOString().split('T')[0]}.sql`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);\n            \n            this.showSuccess('System backup created successfully');\n            \n        } catch (error) {\n            console.error('Error creating backup:', error);\n            this.showError('Failed to create system backup');\n        } finally {\n            this.hideLoading();\n        }\n    }\n    \n    /**\n     * Export system logs\n     */\n    async exportSystemLogs() {\n        try {\n            const response = await fetch('/api/admin/logs/export');\n            if (!response.ok) throw new Error('Failed to export logs');\n            \n            const blob = await response.blob();\n            const url = window.URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `system_logs_${new Date().toISOString().split('T')[0]}.csv`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);\n            \n            this.showSuccess('System logs exported successfully');\n            \n        } catch (error) {\n            console.error('Error exporting logs:', error);\n            this.showError('Failed to export system logs');\n        }\n    }\n    \n    /**\n     * Start system monitoring\n     */\n    startSystemMonitoring() {\n        setInterval(() => {\n            this.loadSystemStatus();\n        }, this.config.refreshInterval);\n    }\n    \n    /**\n     * Show loading state\n     */\n    showLoading(message = 'Loading...') {\n        const loader = document.getElementById('adminLoader');\n        if (loader) {\n            loader.innerHTML = `\n                <div class=\"d-flex align-items-center\">\n                    <div class=\"spinner-border spinner-border-sm me-2\" role=\"status\"></div>\n                    <span>${message}</span>\n                </div>\n            `;\n            loader.style.display = 'block';\n        }\n    }\n    \n    /**\n     * Hide loading state\n     */\n    hideLoading() {\n        const loader = document.getElementById('adminLoader');\n        if (loader) {\n            loader.style.display = 'none';\n        }\n    }\n    \n    /**\n     * Show success message\n     */\n    showSuccess(message) {\n        this.showNotification(message, 'success');\n    }\n    \n    /**\n     * Show error message\n     */\n    showError(message) {\n        this.showNotification(message, 'danger');\n    }\n    \n    /**\n     * Show notification\n     */\n    showNotification(message, type = 'info') {\n        const notification = document.createElement('div');\n        notification.className = `alert alert-${type} alert-dismissible fade show`;\n        notification.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        const container = document.getElementById('adminNotifications') || document.body;\n        container.appendChild(notification);\n        \n        setTimeout(() => {\n            if (notification.parentNode) {\n                notification.parentNode.removeChild(notification);\n            }\n        }, 5000);\n    }\n}\n\n// Initialize admin panel when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.amlAdminPanel = new AMLAdminPanel();\n});\n","size_bytes":21230},"static/js/dashboard.js":{"content":"/**\n * Banking AML Dashboard - Main JavaScript Module\n * Real-time monitoring and interactive dashboard functionality\n */\n\nclass AMLDashboard {\n    constructor() {\n        this.websocket = null;\n        this.charts = {};\n        this.alertsTable = null;\n        this.isConnected = false;\n        \n        // Configuration\n        this.config = {\n            refreshInterval: 30000, // 30 seconds\n            maxAlerts: 100,\n            riskThresholds: {\n                low: 0.3,\n                medium: 0.6,\n                high: 0.8,\n                critical: 0.9\n            }\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * Initialize the dashboard\n     */\n    async init() {\n        console.log('Initializing AML Dashboard...');\n        \n        try {\n            await this.setupWebSocket();\n            await this.loadInitialData();\n            await this.initializeCharts();\n            await this.setupEventListeners();\n            await this.startPeriodicRefresh();\n            \n            console.log('Dashboard initialized successfully');\n        } catch (error) {\n            console.error('Error initializing dashboard:', error);\n            this.showError('Failed to initialize dashboard');\n        }\n    }\n    \n    /**\n     * Setup WebSocket connection for real-time updates\n     */\n    async setupWebSocket() {\n        try {\n            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n            const wsUrl = `${protocol}//${window.location.host}/ws`;\n            \n            this.websocket = new WebSocket(wsUrl);\n            \n            this.websocket.onopen = () => {\n                console.log('WebSocket connected');\n                this.isConnected = true;\n                this.updateConnectionStatus(true);\n            };\n            \n            this.websocket.onmessage = (event) => {\n                this.handleWebSocketMessage(JSON.parse(event.data));\n            };\n            \n            this.websocket.onclose = () => {\n                console.log('WebSocket disconnected');\n                this.isConnected = false;\n                this.updateConnectionStatus(false);\n                \n                // Attempt to reconnect after 5 seconds\n                setTimeout(() => this.setupWebSocket(), 5000);\n            };\n            \n            this.websocket.onerror = (error) => {\n                console.error('WebSocket error:', error);\n                this.showError('Real-time connection error');\n            };\n            \n        } catch (error) {\n            console.error('Error setting up WebSocket:', error);\n        }\n    }\n    \n    /**\n     * Handle incoming WebSocket messages\n     */\n    handleWebSocketMessage(message) {\n        console.log('Received real-time message:', message);\n        \n        switch (message.type) {\n            case 'new_alert':\n                this.handleNewAlert(message.alert);\n                break;\n            case 'transaction_processed':\n                this.handleNewTransaction(message.transaction);\n                break;\n            case 'case_updated':\n                this.handleCaseUpdate(message.case);\n                break;\n            case 'system_status':\n                this.handleSystemStatus(message.status);\n                break;\n            default:\n                console.log('Unknown message type:', message.type);\n        }\n    }\n    \n    /**\n     * Load initial dashboard data\n     */\n    async loadInitialData() {\n        try {\n            this.showLoading(true);\n            \n            // Load dashboard statistics\n            const statsResponse = await fetch('/api/dashboard/stats');\n            if (!statsResponse.ok) throw new Error('Failed to load stats');\n            const stats = await statsResponse.json();\n            \n            this.updateDashboardStats(stats);\n            \n            // Load recent alerts\n            const alertsResponse = await fetch('/api/alerts/?limit=50');\n            if (!alertsResponse.ok) throw new Error('Failed to load alerts');\n            const alerts = await alertsResponse.json();\n            \n            this.updateAlertsTable(alerts);\n            \n        } catch (error) {\n            console.error('Error loading initial data:', error);\n            this.showError('Failed to load dashboard data');\n        } finally {\n            this.showLoading(false);\n        }\n    }\n    \n    /**\n     * Update dashboard statistics\n     */\n    updateDashboardStats(stats) {\n        // Update metric cards\n        this.updateMetricCard('today-transactions', stats.today_transactions);\n        this.updateMetricCard('open-alerts', stats.open_alerts);\n        this.updateMetricCard('high-risk-alerts', stats.high_risk_alerts);\n        \n        // Update risk distribution chart\n        if (this.charts.riskDistribution) {\n            this.updateRiskDistributionChart(stats.risk_distribution);\n        }\n        \n        // Update alert trends\n        this.updateAlertTrends(stats.alert_trends);\n    }\n    \n    /**\n     * Update metric card value\n     */\n    updateMetricCard(cardId, value, change = null) {\n        const card = document.getElementById(cardId);\n        if (!card) return;\n        \n        const valueElement = card.querySelector('.metric-value');\n        const changeElement = card.querySelector('.metric-change');\n        \n        if (valueElement) {\n            // Animate the value change\n            this.animateNumber(valueElement, parseInt(valueElement.textContent) || 0, value);\n        }\n        \n        if (changeElement && change !== null) {\n            changeElement.textContent = `${change > 0 ? '+' : ''}${change}%`;\n            changeElement.className = `metric-change ${change > 0 ? 'change-positive' : 'change-negative'}`;\n        }\n    }\n    \n    /**\n     * Animate number changes\n     */\n    animateNumber(element, start, end, duration = 1000) {\n        const startTime = Date.now();\n        const range = end - start;\n        \n        const timer = setInterval(() => {\n            const elapsed = Date.now() - startTime;\n            const progress = Math.min(elapsed / duration, 1);\n            \n            // Easing function\n            const easeOutCubic = 1 - Math.pow(1 - progress, 3);\n            const current = Math.round(start + (range * easeOutCubic));\n            \n            element.textContent = current.toLocaleString();\n            \n            if (progress === 1) {\n                clearInterval(timer);\n            }\n        }, 16);\n    }\n    \n    /**\n     * Initialize charts\n     */\n    async initializeCharts() {\n        try {\n            // Risk Distribution Pie Chart\n            await this.initRiskDistributionChart();\n            \n            // Alert Trends Line Chart\n            await this.initAlertTrendsChart();\n            \n            // Transaction Volume Chart\n            await this.initTransactionVolumeChart();\n            \n        } catch (error) {\n            console.error('Error initializing charts:', error);\n        }\n    }\n    \n    /**\n     * Initialize risk distribution chart\n     */\n    async initRiskDistributionChart() {\n        const ctx = document.getElementById('riskDistributionChart');\n        if (!ctx) return;\n        \n        this.charts.riskDistribution = new Chart(ctx, {\n            type: 'doughnut',\n            data: {\n                labels: ['Low Risk', 'Medium Risk', 'High Risk', 'Critical Risk'],\n                datasets: [{\n                    data: [0, 0, 0, 0],\n                    backgroundColor: [\n                        '#28a745', // Green\n                        '#ffc107', // Yellow\n                        '#fd7e14', // Orange\n                        '#dc3545'  // Red\n                    ],\n                    borderWidth: 2,\n                    borderColor: '#ffffff'\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        position: 'bottom',\n                        labels: {\n                            padding: 20,\n                            usePointStyle: true\n                        }\n                    },\n                    tooltip: {\n                        callbacks: {\n                            label: function(context) {\n                                const label = context.label || '';\n                                const value = context.parsed;\n                                const total = context.dataset.data.reduce((a, b) => a + b, 0);\n                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;\n                                return `${label}: ${value} (${percentage}%)`;\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * Initialize alert trends chart\n     */\n    async initAlertTrendsChart() {\n        const ctx = document.getElementById('alertTrendsChart');\n        if (!ctx) return;\n        \n        this.charts.alertTrends = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: [],\n                datasets: [{\n                    label: 'High Risk Alerts',\n                    data: [],\n                    borderColor: '#dc3545',\n                    backgroundColor: 'rgba(220, 53, 69, 0.1)',\n                    tension: 0.4,\n                    fill: true\n                }, {\n                    label: 'Medium Risk Alerts',\n                    data: [],\n                    borderColor: '#ffc107',\n                    backgroundColor: 'rgba(255, 193, 7, 0.1)',\n                    tension: 0.4,\n                    fill: true\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    intersect: false,\n                    mode: 'index'\n                },\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Number of Alerts'\n                        }\n                    },\n                    x: {\n                        title: {\n                            display: true,\n                            text: 'Time'\n                        }\n                    }\n                },\n                plugins: {\n                    legend: {\n                        position: 'top'\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * Initialize transaction volume chart\n     */\n    async initTransactionVolumeChart() {\n        const ctx = document.getElementById('transactionVolumeChart');\n        if (!ctx) return;\n        \n        this.charts.transactionVolume = new Chart(ctx, {\n            type: 'bar',\n            data: {\n                labels: [],\n                datasets: [{\n                    label: 'Transaction Volume (USD)',\n                    data: [],\n                    backgroundColor: 'rgba(30, 58, 95, 0.8)',\n                    borderColor: '#1e3a5f',\n                    borderWidth: 1\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Volume (USD)'\n                        },\n                        ticks: {\n                            callback: function(value) {\n                                return '$' + value.toLocaleString();\n                            }\n                        }\n                    }\n                },\n                plugins: {\n                    tooltip: {\n                        callbacks: {\n                            label: function(context) {\n                                return 'Volume: $' + context.parsed.y.toLocaleString();\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * Update risk distribution chart\n     */\n    updateRiskDistributionChart(riskData) {\n        if (!this.charts.riskDistribution) return;\n        \n        const chart = this.charts.riskDistribution;\n        const newData = [0, 0, 0, 0]; // [low, medium, high, critical]\n        \n        riskData.forEach(item => {\n            const avgRisk = item.avg_risk;\n            const count = item.count;\n            \n            if (avgRisk < this.config.riskThresholds.medium) {\n                newData[0] += count;\n            } else if (avgRisk < this.config.riskThresholds.high) {\n                newData[1] += count;\n            } else if (avgRisk < this.config.riskThresholds.critical) {\n                newData[2] += count;\n            } else {\n                newData[3] += count;\n            }\n        });\n        \n        chart.data.datasets[0].data = newData;\n        chart.update('active');\n    }\n    \n    /**\n     * Handle new alert from WebSocket\n     */\n    handleNewAlert(alert) {\n        console.log('New alert received:', alert);\n        \n        // Show notification\n        this.showNotification(`New ${alert.type} alert`, 'warning');\n        \n        // Update alerts table\n        this.addAlertToTable(alert);\n        \n        // Update metrics\n        this.incrementMetricCard('open-alerts');\n        \n        if (alert.risk_score >= 0.8) {\n            this.incrementMetricCard('high-risk-alerts');\n        }\n        \n        // Play notification sound for high-risk alerts\n        if (alert.risk_score >= 0.8) {\n            this.playNotificationSound();\n        }\n    }\n    \n    /**\n     * Handle new transaction from WebSocket\n     */\n    handleNewTransaction(transaction) {\n        // Update transaction count\n        this.incrementMetricCard('today-transactions');\n        \n        // Update transaction volume chart if visible\n        if (this.charts.transactionVolume) {\n            this.updateTransactionVolumeChart(transaction);\n        }\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    async setupEventListeners() {\n        // Refresh button\n        const refreshBtn = document.getElementById('refreshDashboard');\n        if (refreshBtn) {\n            refreshBtn.addEventListener('click', () => this.refreshDashboard());\n        }\n        \n        // Export buttons\n        const exportBtn = document.getElementById('exportAlerts');\n        if (exportBtn) {\n            exportBtn.addEventListener('click', () => this.exportAlerts());\n        }\n        \n        // Alert filters\n        const statusFilter = document.getElementById('alertStatusFilter');\n        if (statusFilter) {\n            statusFilter.addEventListener('change', () => this.filterAlerts());\n        }\n        \n        const typeFilter = document.getElementById('alertTypeFilter');\n        if (typeFilter) {\n            typeFilter.addEventListener('change', () => this.filterAlerts());\n        }\n        \n        // Modal triggers\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('view-alert-btn')) {\n                const alertId = e.target.dataset.alertId;\n                this.showAlertDetails(alertId);\n            }\n            \n            if (e.target.classList.contains('create-case-btn')) {\n                const alertId = e.target.dataset.alertId;\n                this.showCreateCaseModal(alertId);\n            }\n        });\n        \n        // Window resize handler for charts\n        window.addEventListener('resize', () => {\n            Object.values(this.charts).forEach(chart => {\n                if (chart && typeof chart.resize === 'function') {\n                    chart.resize();\n                }\n            });\n        });\n        \n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (e.ctrlKey || e.metaKey) {\n                switch (e.key) {\n                    case 'r':\n                        e.preventDefault();\n                        this.refreshDashboard();\n                        break;\n                    case 'e':\n                        e.preventDefault();\n                        this.exportAlerts();\n                        break;\n                }\n            }\n        });\n    }\n    \n    /**\n     * Update alerts table\n     */\n    updateAlertsTable(alerts) {\n        const tbody = document.querySelector('#alertsTable tbody');\n        if (!tbody) return;\n        \n        tbody.innerHTML = '';\n        \n        alerts.forEach(alert => {\n            this.addAlertToTable(alert);\n        });\n    }\n    \n    /**\n     * Add alert to table\n     */\n    addAlertToTable(alert) {\n        const tbody = document.querySelector('#alertsTable tbody');\n        if (!tbody) return;\n        \n        const row = document.createElement('tr');\n        row.innerHTML = `\n            <td>\n                <div class=\"d-flex align-items-center\">\n                    <div class=\"risk-score risk-${this.getRiskLevel(alert.risk_score)}\">\n                        ${(alert.risk_score * 100).toFixed(0)}\n                    </div>\n                    <div class=\"ms-2\">\n                        <div class=\"fw-semibold\">${alert.id}</div>\n                        <small class=\"text-muted\">${new Date(alert.created_at).toLocaleString()}</small>\n                    </div>\n                </div>\n            </td>\n            <td>\n                <span class=\"badge bg-secondary\">${alert.alert_type}</span>\n            </td>\n            <td>${alert.customer_id}</td>\n            <td>${this.formatCurrency(alert.transaction?.amount || 0)} ${alert.transaction?.currency || 'USD'}</td>\n            <td>\n                <span class=\"status-badge status-${alert.status.toLowerCase()}\">${alert.status}</span>\n            </td>\n            <td>\n                <div class=\"btn-group btn-group-sm\">\n                    <button class=\"btn btn-outline-primary view-alert-btn\" data-alert-id=\"${alert.id}\">\n                        <i class=\"fas fa-eye\"></i>\n                    </button>\n                    <button class=\"btn btn-outline-success create-case-btn\" data-alert-id=\"${alert.id}\">\n                        <i class=\"fas fa-plus\"></i>\n                    </button>\n                </div>\n            </td>\n        `;\n        \n        tbody.insertBefore(row, tbody.firstChild);\n        \n        // Remove oldest row if table has too many rows\n        const rows = tbody.querySelectorAll('tr');\n        if (rows.length > this.config.maxAlerts) {\n            tbody.removeChild(rows[rows.length - 1]);\n        }\n    }\n    \n    /**\n     * Get risk level from score\n     */\n    getRiskLevel(score) {\n        if (score >= this.config.riskThresholds.critical) return 'critical';\n        if (score >= this.config.riskThresholds.high) return 'high';\n        if (score >= this.config.riskThresholds.medium) return 'medium';\n        return 'low';\n    }\n    \n    /**\n     * Format currency\n     */\n    formatCurrency(amount, currency = 'USD') {\n        return new Intl.NumberFormat('en-US', {\n            style: 'currency',\n            currency: currency\n        }).format(amount);\n    }\n    \n    /**\n     * Increment metric card value\n     */\n    incrementMetricCard(cardId) {\n        const card = document.getElementById(cardId);\n        if (!card) return;\n        \n        const valueElement = card.querySelector('.metric-value');\n        if (valueElement) {\n            const currentValue = parseInt(valueElement.textContent.replace(/,/g, '')) || 0;\n            this.animateNumber(valueElement, currentValue, currentValue + 1);\n        }\n    }\n    \n    /**\n     * Start periodic refresh\n     */\n    startPeriodicRefresh() {\n        setInterval(() => {\n            if (!this.isConnected) {\n                this.loadInitialData();\n            }\n        }, this.config.refreshInterval);\n    }\n    \n    /**\n     * Refresh dashboard manually\n     */\n    async refreshDashboard() {\n        console.log('Refreshing dashboard...');\n        await this.loadInitialData();\n        this.showNotification('Dashboard refreshed', 'success');\n    }\n    \n    /**\n     * Update connection status indicator\n     */\n    updateConnectionStatus(connected) {\n        const indicator = document.querySelector('.realtime-indicator');\n        if (!indicator) return;\n        \n        if (connected) {\n            indicator.className = 'realtime-indicator';\n            indicator.innerHTML = '<span class=\"realtime-dot\"></span>Real-time Connected';\n            indicator.style.backgroundColor = '#28a745';\n        } else {\n            indicator.className = 'realtime-indicator';\n            indicator.innerHTML = '<span class=\"realtime-dot\"></span>Connection Lost';\n            indicator.style.backgroundColor = '#dc3545';\n        }\n    }\n    \n    /**\n     * Show notification\n     */\n    showNotification(message, type = 'info') {\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = `alert alert-${type} alert-dismissible fade show`;\n        notification.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        // Add to notifications container\n        const container = document.getElementById('notifications') || document.body;\n        container.appendChild(notification);\n        \n        // Auto-remove after 5 seconds\n        setTimeout(() => {\n            if (notification.parentNode) {\n                notification.parentNode.removeChild(notification);\n            }\n        }, 5000);\n    }\n    \n    /**\n     * Show error message\n     */\n    showError(message) {\n        this.showNotification(message, 'danger');\n    }\n    \n    /**\n     * Show/hide loading state\n     */\n    showLoading(show) {\n        const loader = document.getElementById('dashboardLoader');\n        if (loader) {\n            loader.style.display = show ? 'block' : 'none';\n        }\n    }\n    \n    /**\n     * Play notification sound\n     */\n    playNotificationSound() {\n        try {\n            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBl');\n            audio.play().catch(() => {\n                // Ignore errors if audio cannot be played\n            });\n        } catch (error) {\n            // Ignore errors\n        }\n    }\n    \n    /**\n     * Show alert details modal\n     */\n    async showAlertDetails(alertId) {\n        try {\n            const response = await fetch(`/api/alerts/${alertId}`);\n            if (!response.ok) throw new Error('Failed to load alert details');\n            \n            const alert = await response.json();\n            \n            // Create and show modal\n            const modal = this.createAlertDetailsModal(alert);\n            document.body.appendChild(modal);\n            \n            // Show modal with Bootstrap\n            if (typeof bootstrap !== 'undefined') {\n                new bootstrap.Modal(modal).show();\n            }\n            \n        } catch (error) {\n            console.error('Error showing alert details:', error);\n            this.showError('Failed to load alert details');\n        }\n    }\n    \n    /**\n     * Create alert details modal\n     */\n    createAlertDetailsModal(alert) {\n        const modal = document.createElement('div');\n        modal.className = 'modal fade';\n        modal.innerHTML = `\n            <div class=\"modal-dialog modal-lg\">\n                <div class=\"modal-content\">\n                    <div class=\"modal-header\">\n                        <h5 class=\"modal-title\">Alert Details - ${alert.id}</h5>\n                        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                    </div>\n                    <div class=\"modal-body\">\n                        <div class=\"row\">\n                            <div class=\"col-md-6\">\n                                <h6>Alert Information</h6>\n                                <table class=\"table table-sm\">\n                                    <tr><td>Alert Type</td><td>${alert.alert_type}</td></tr>\n                                    <tr><td>Risk Score</td><td><span class=\"risk-score risk-${this.getRiskLevel(alert.risk_score)}\">${(alert.risk_score * 100).toFixed(0)}</span></td></tr>\n                                    <tr><td>Status</td><td><span class=\"status-badge status-${alert.status.toLowerCase()}\">${alert.status}</span></td></tr>\n                                    <tr><td>Priority</td><td>${alert.priority || 'Medium'}</td></tr>\n                                    <tr><td>Created</td><td>${new Date(alert.created_at).toLocaleString()}</td></tr>\n                                </table>\n                            </div>\n                            <div class=\"col-md-6\">\n                                <h6>Transaction Details</h6>\n                                <table class=\"table table-sm\">\n                                    <tr><td>Transaction ID</td><td>${alert.transaction_id}</td></tr>\n                                    <tr><td>Customer ID</td><td>${alert.customer_id}</td></tr>\n                                    <tr><td>Amount</td><td>${this.formatCurrency(alert.transaction?.amount || 0)} ${alert.transaction?.currency || 'USD'}</td></tr>\n                                    <tr><td>Channel</td><td>${alert.transaction?.channel || 'N/A'}</td></tr>\n                                    <tr><td>Type</td><td>${alert.transaction?.transaction_type || 'N/A'}</td></tr>\n                                </table>\n                            </div>\n                        </div>\n                        <div class=\"mt-3\">\n                            <h6>Description</h6>\n                            <p>${alert.description}</p>\n                        </div>\n                    </div>\n                    <div class=\"modal-footer\">\n                        <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                        <button type=\"button\" class=\"btn btn-success create-case-btn\" data-alert-id=\"${alert.id}\">Create Case</button>\n                    </div>\n                </div>\n            </div>\n        `;\n        \n        return modal;\n    }\n    \n    /**\n     * Export alerts to CSV\n     */\n    async exportAlerts() {\n        try {\n            const response = await fetch('/api/alerts/export');\n            if (!response.ok) throw new Error('Failed to export alerts');\n            \n            const blob = await response.blob();\n            const url = window.URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `alerts_${new Date().toISOString().split('T')[0]}.csv`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            window.URL.revokeObjectURL(url);\n            \n            this.showNotification('Alerts exported successfully', 'success');\n            \n        } catch (error) {\n            console.error('Error exporting alerts:', error);\n            this.showError('Failed to export alerts');\n        }\n    }\n}\n\n// Initialize dashboard when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.amlDashboard = new AMLDashboard();\n});\n","size_bytes":27598},"static/js/real-time-monitoring.js":{"content":"/**\n * Real-time Monitoring Module\n * Advanced real-time transaction monitoring and alert management\n */\n\nclass RealTimeMonitor {\n    constructor() {\n        this.websocket = null;\n        this.isConnected = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        this.reconnectInterval = 5000;\n        \n        this.monitoringData = {\n            transactions: [],\n            alerts: [],\n            systemMetrics: {}\n        };\n        \n        this.charts = {\n            realTimeFlow: null,\n            riskDistribution: null,\n            transactionVolume: null,\n            alertTrends: null\n        };\n        \n        this.filters = {\n            riskLevel: 'all',\n            alertType: 'all',\n            timeRange: '1h'\n        };\n        \n        this.init();\n    }\n    \n    /**\n     * Initialize real-time monitoring\n     */\n    async init() {\n        console.log('Initializing Real-time Monitor...');\n        \n        try {\n            await this.setupWebSocket();\n            await this.initializeCharts();\n            await this.setupEventListeners();\n            await this.loadInitialData();\n            \n            console.log('Real-time monitor initialized successfully');\n        } catch (error) {\n            console.error('Error initializing real-time monitor:', error);\n        }\n    }\n    \n    /**\n     * Setup WebSocket connection\n     */\n    async setupWebSocket() {\n        try {\n            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n            const wsUrl = `${protocol}//${window.location.host}/ws`;\n            \n            this.websocket = new WebSocket(wsUrl);\n            \n            this.websocket.onopen = () => {\n                console.log('Real-time WebSocket connected');\n                this.isConnected = true;\n                this.reconnectAttempts = 0;\n                this.updateConnectionStatus(true);\n                \n                // Subscribe to real-time updates\n                this.subscribeToUpdates();\n            };\n            \n            this.websocket.onmessage = (event) => {\n                const message = JSON.parse(event.data);\n                this.handleRealtimeMessage(message);\n            };\n            \n            this.websocket.onclose = () => {\n                console.log('Real-time WebSocket disconnected');\n                this.isConnected = false;\n                this.updateConnectionStatus(false);\n                this.attemptReconnect();\n            };\n            \n            this.websocket.onerror = (error) => {\n                console.error('WebSocket error:', error);\n            };\n            \n        } catch (error) {\n            console.error('Error setting up WebSocket:', error);\n        }\n    }\n    \n    /**\n     * Attempt to reconnect WebSocket\n     */\n    attemptReconnect() {\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.reconnectAttempts++;\n            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n            \n            setTimeout(() => {\n                this.setupWebSocket();\n            }, this.reconnectInterval);\n        } else {\n            console.error('Max reconnection attempts reached');\n            this.showConnectionError();\n        }\n    }\n    \n    /**\n     * Subscribe to real-time updates\n     */\n    subscribeToUpdates() {\n        if (this.websocket && this.isConnected) {\n            this.websocket.send(JSON.stringify({\n                type: 'subscribe',\n                channels: ['transactions', 'alerts', 'system_metrics', 'ml_predictions']\n            }));\n        }\n    }\n    \n    /**\n     * Handle real-time messages\n     */\n    handleRealtimeMessage(message) {\n        switch (message.type) {\n            case 'transaction_stream':\n                this.handleTransactionStream(message.data);\n                break;\n                \n            case 'alert_generated':\n                this.handleNewAlert(message.data);\n                break;\n                \n            case 'ml_prediction':\n                this.handleMLPrediction(message.data);\n                break;\n                \n            case 'system_metrics':\n                this.handleSystemMetrics(message.data);\n                break;\n                \n            case 'risk_score_update':\n                this.handleRiskScoreUpdate(message.data);\n                break;\n                \n            default:\n                console.log('Unknown message type:', message.type);\n        }\n    }\n    \n    /**\n     * Handle transaction stream\n     */\n    handleTransactionStream(transactions) {\n        transactions.forEach(transaction => {\n            this.addTransactionToStream(transaction);\n        });\n        \n        this.updateTransactionFlowChart();\n        this.updateVolumeChart();\n    }\n    \n    /**\n     * Add transaction to real-time stream\n     */\n    addTransactionToStream(transaction) {\n        // Add to beginning of array\n        this.monitoringData.transactions.unshift(transaction);\n        \n        // Keep only last 100 transactions for performance\n        if (this.monitoringData.transactions.length > 100) {\n            this.monitoringData.transactions = this.monitoringData.transactions.slice(0, 100);\n        }\n        \n        // Update transaction stream display\n        this.updateTransactionStreamDisplay(transaction);\n        \n        // Check if transaction meets filter criteria\n        if (this.matchesFilter(transaction)) {\n            this.addTransactionToTable(transaction);\n        }\n    }\n    \n    /**\n     * Update transaction stream display\n     */\n    updateTransactionStreamDisplay(transaction) {\n        const streamContainer = document.getElementById('transactionStream');\n        if (!streamContainer) return;\n        \n        const transactionElement = document.createElement('div');\n        transactionElement.className = `transaction-item risk-${this.getRiskLevel(transaction.risk_score)}`;\n        transactionElement.innerHTML = `\n            <div class=\"transaction-flow\">\n                <div class=\"flow-step\">\n                    <div class=\"flow-icon\">\n                        <i class=\"fas fa-user\"></i>\n                    </div>\n                    <div class=\"flow-label\">${this.maskCustomerId(transaction.customer_id)}</div>\n                </div>\n                <div class=\"flow-step\">\n                    <div class=\"flow-icon\">\n                        <i class=\"fas fa-exchange-alt\"></i>\n                    </div>\n                    <div class=\"flow-label\">${this.formatCurrency(transaction.amount)} ${transaction.currency}</div>\n                </div>\n                <div class=\"flow-step\">\n                    <div class=\"flow-icon\">\n                        <i class=\"fas fa-shield-alt\"></i>\n                    </div>\n                    <div class=\"flow-label\">Risk: ${(transaction.risk_score * 100).toFixed(0)}%</div>\n                </div>\n            </div>\n            <div class=\"transaction-meta\">\n                <span class=\"transaction-time\">${new Date(transaction.timestamp).toLocaleTimeString()}</span>\n                <span class=\"transaction-channel\">${transaction.channel}</span>\n                ${transaction.ml_prediction ? `<span class=\"ml-prediction\">ML: ${transaction.ml_prediction}</span>` : ''}\n            </div>\n        `;\n        \n        // Add animation\n        transactionElement.style.opacity = '0';\n        transactionElement.style.transform = 'translateY(-20px)';\n        \n        streamContainer.insertBefore(transactionElement, streamContainer.firstChild);\n        \n        // Animate in\n        setTimeout(() => {\n            transactionElement.style.transition = 'all 0.3s ease';\n            transactionElement.style.opacity = '1';\n            transactionElement.style.transform = 'translateY(0)';\n        }, 10);\n        \n        // Remove old items\n        const items = streamContainer.children;\n        if (items.length > 10) {\n            for (let i = 10; i < items.length; i++) {\n                streamContainer.removeChild(items[i]);\n            }\n        }\n    }\n    \n    /**\n     * Handle new alert\n     */\n    handleNewAlert(alert) {\n        console.log('New real-time alert:', alert);\n        \n        // Add to alerts array\n        this.monitoringData.alerts.unshift(alert);\n        \n        // Keep only last 50 alerts\n        if (this.monitoringData.alerts.length > 50) {\n            this.monitoringData.alerts = this.monitoringData.alerts.slice(0, 50);\n        }\n        \n        // Show alert notification\n        this.showAlertNotification(alert);\n        \n        // Update alert display\n        this.updateAlertDisplay(alert);\n        \n        // Update charts\n        this.updateRiskDistributionChart();\n        this.updateAlertTrendsChart();\n        \n        // Play sound for high-risk alerts\n        if (alert.risk_score >= 0.8) {\n            this.playAlertSound();\n        }\n    }\n    \n    /**\n     * Handle ML prediction\n     */\n    handleMLPrediction(prediction) {\n        console.log('ML prediction received:', prediction);\n        \n        // Update ML metrics display\n        this.updateMLMetrics(prediction);\n        \n        // Show ML prediction in transaction stream if applicable\n        const transaction = this.monitoringData.transactions.find(t => t.id === prediction.transaction_id);\n        if (transaction) {\n            transaction.ml_prediction = prediction.prediction;\n            transaction.ml_confidence = prediction.confidence;\n        }\n    }\n    \n    /**\n     * Handle system metrics update\n     */\n    handleSystemMetrics(metrics) {\n        this.monitoringData.systemMetrics = metrics;\n        this.updateSystemMetricsDisplay(metrics);\n    }\n    \n    /**\n     * Initialize real-time charts\n     */\n    async initializeCharts() {\n        await this.initTransactionFlowChart();\n        await this.initRiskDistributionChart();\n        await this.initVolumeChart();\n        await this.initAlertTrendsChart();\n    }\n    \n    /**\n     * Initialize transaction flow chart\n     */\n    async initTransactionFlowChart() {\n        const ctx = document.getElementById('realTimeFlowChart');\n        if (!ctx) return;\n        \n        this.charts.realTimeFlow = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: [],\n                datasets: [{\n                    label: 'Transactions/min',\n                    data: [],\n                    borderColor: '#1e3a5f',\n                    backgroundColor: 'rgba(30, 58, 95, 0.1)',\n                    tension: 0.4,\n                    fill: true\n                }, {\n                    label: 'High Risk Transactions/min',\n                    data: [],\n                    borderColor: '#dc3545',\n                    backgroundColor: 'rgba(220, 53, 69, 0.1)',\n                    tension: 0.4,\n                    fill: true\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                animation: {\n                    duration: 300\n                },\n                scales: {\n                    x: {\n                        type: 'time',\n                        time: {\n                            displayFormats: {\n                                minute: 'HH:mm'\n                            }\n                        },\n                        title: {\n                            display: true,\n                            text: 'Time'\n                        }\n                    },\n                    y: {\n                        beginAtZero: true,\n                        title: {\n                            display: true,\n                            text: 'Transactions per Minute'\n                        }\n                    }\n                },\n                plugins: {\n                    legend: {\n                        position: 'top'\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * Initialize risk distribution chart\n     */\n    async initRiskDistributionChart() {\n        const ctx = document.getElementById('realTimeRiskChart');\n        if (!ctx) return;\n        \n        this.charts.riskDistribution = new Chart(ctx, {\n            type: 'doughnut',\n            data: {\n                labels: ['Low Risk', 'Medium Risk', 'High Risk', 'Critical Risk'],\n                datasets: [{\n                    data: [0, 0, 0, 0],\n                    backgroundColor: ['#28a745', '#ffc107', '#fd7e14', '#dc3545'],\n                    borderWidth: 2,\n                    borderColor: '#ffffff'\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                animation: {\n                    animateRotate: true,\n                    duration: 500\n                },\n                plugins: {\n                    legend: {\n                        position: 'bottom'\n                    }\n                }\n            }\n        });\n    }\n    \n    /**\n     * Update transaction flow chart\n     */\n    updateTransactionFlowChart() {\n        if (!this.charts.realTimeFlow) return;\n        \n        const chart = this.charts.realTimeFlow;\n        const now = new Date();\n        \n        // Calculate transactions per minute\n        const recentTransactions = this.monitoringData.transactions.filter(\n            t => new Date(t.timestamp) > new Date(now.getTime() - 60000) // Last minute\n        );\n        \n        const highRiskTransactions = recentTransactions.filter(t => t.risk_score >= 0.8);\n        \n        // Add data point\n        chart.data.labels.push(now);\n        chart.data.datasets[0].data.push(recentTransactions.length);\n        chart.data.datasets[1].data.push(highRiskTransactions.length);\n        \n        // Keep only last 20 data points\n        if (chart.data.labels.length > 20) {\n            chart.data.labels = chart.data.labels.slice(-20);\n            chart.data.datasets[0].data = chart.data.datasets[0].data.slice(-20);\n            chart.data.datasets[1].data = chart.data.datasets[1].data.slice(-20);\n        }\n        \n        chart.update('none');\n    }\n    \n    /**\n     * Setup event listeners\n     */\n    async setupEventListeners() {\n        // Filter controls\n        const riskFilter = document.getElementById('riskLevelFilter');\n        if (riskFilter) {\n            riskFilter.addEventListener('change', (e) => {\n                this.filters.riskLevel = e.target.value;\n                this.applyFilters();\n            });\n        }\n        \n        const alertTypeFilter = document.getElementById('alertTypeFilter');\n        if (alertTypeFilter) {\n            alertTypeFilter.addEventListener('change', (e) => {\n                this.filters.alertType = e.target.value;\n                this.applyFilters();\n            });\n        }\n        \n        const timeRangeFilter = document.getElementById('timeRangeFilter');\n        if (timeRangeFilter) {\n            timeRangeFilter.addEventListener('change', (e) => {\n                this.filters.timeRange = e.target.value;\n                this.applyFilters();\n            });\n        }\n        \n        // Control buttons\n        const pauseBtn = document.getElementById('pauseMonitoring');\n        if (pauseBtn) {\n            pauseBtn.addEventListener('click', () => this.toggleMonitoring());\n        }\n        \n        const clearBtn = document.getElementById('clearStream');\n        if (clearBtn) {\n            clearBtn.addEventListener('click', () => this.clearTransactionStream());\n        }\n        \n        const exportBtn = document.getElementById('exportRealTimeData');\n        if (exportBtn) {\n            exportBtn.addEventListener('click', () => this.exportRealTimeData());\n        }\n        \n        // Alert actions\n        document.addEventListener('click', (e) => {\n            if (e.target.classList.contains('acknowledge-alert-btn')) {\n                const alertId = e.target.dataset.alertId;\n                this.acknowledgeAlert(alertId);\n            }\n            \n            if (e.target.classList.contains('investigate-alert-btn')) {\n                const alertId = e.target.dataset.alertId;\n                this.startInvestigation(alertId);\n            }\n        });\n    }\n    \n    /**\n     * Apply filters to displayed data\n     */\n    applyFilters() {\n        const filteredTransactions = this.monitoringData.transactions.filter(t => this.matchesFilter(t));\n        const filteredAlerts = this.monitoringData.alerts.filter(a => this.matchesAlertFilter(a));\n        \n        this.updateFilteredDisplay(filteredTransactions, filteredAlerts);\n    }\n    \n    /**\n     * Check if transaction matches current filters\n     */\n    matchesFilter(transaction) {\n        // Risk level filter\n        if (this.filters.riskLevel !== 'all') {\n            const riskLevel = this.getRiskLevel(transaction.risk_score);\n            if (riskLevel !== this.filters.riskLevel) return false;\n        }\n        \n        // Time range filter\n        const now = new Date();\n        const transactionTime = new Date(transaction.timestamp);\n        const timeDiff = now.getTime() - transactionTime.getTime();\n        \n        switch (this.filters.timeRange) {\n            case '1h':\n                if (timeDiff > 3600000) return false; // 1 hour\n                break;\n            case '4h':\n                if (timeDiff > 14400000) return false; // 4 hours\n                break;\n            case '24h':\n                if (timeDiff > 86400000) return false; // 24 hours\n                break;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * Show alert notification\n     */\n    showAlertNotification(alert) {\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = `alert-notification ${this.getRiskLevel(alert.risk_score)}`;\n        notification.innerHTML = `\n            <div class=\"notification-header\">\n                <i class=\"fas fa-exclamation-triangle\"></i>\n                <strong>New ${alert.alert_type} Alert</strong>\n                <button class=\"close-notification\" onclick=\"this.parentElement.parentElement.remove()\">×</button>\n            </div>\n            <div class=\"notification-body\">\n                <p>Risk Score: <span class=\"risk-score\">${(alert.risk_score * 100).toFixed(0)}%</span></p>\n                <p>Customer: ${this.maskCustomerId(alert.customer_id)}</p>\n                <p>${alert.description}</p>\n            </div>\n            <div class=\"notification-actions\">\n                <button class=\"btn btn-sm btn-outline-primary acknowledge-alert-btn\" data-alert-id=\"${alert.id}\">\n                    Acknowledge\n                </button>\n                <button class=\"btn btn-sm btn-primary investigate-alert-btn\" data-alert-id=\"${alert.id}\">\n                    Investigate\n                </button>\n            </div>\n        `;\n        \n        // Add to notifications container\n        const container = document.getElementById('alertNotifications');\n        if (container) {\n            container.appendChild(notification);\n            \n            // Auto-remove after 10 seconds for low-risk alerts\n            if (alert.risk_score < 0.6) {\n                setTimeout(() => {\n                    if (notification.parentNode) {\n                        notification.parentNode.removeChild(notification);\n                    }\n                }, 10000);\n            }\n        }\n    }\n    \n    /**\n     * Play alert sound\n     */\n    playAlertSound() {\n        try {\n            const audio = new Audio('/static/sounds/alert.mp3');\n            audio.volume = 0.5;\n            audio.play().catch(() => {\n                // Fallback to system beep\n                console.log('\\u0007'); // ASCII bell character\n            });\n        } catch (error) {\n            console.log('Could not play alert sound');\n        }\n    }\n    \n    /**\n     * Update connection status\n     */\n    updateConnectionStatus(connected) {\n        const statusElement = document.getElementById('connectionStatus');\n        if (!statusElement) return;\n        \n        if (connected) {\n            statusElement.className = 'connection-status connected';\n            statusElement.innerHTML = '<i class=\"fas fa-wifi\"></i> Connected';\n        } else {\n            statusElement.className = 'connection-status disconnected';\n            statusElement.innerHTML = '<i class=\"fas fa-wifi-slash\"></i> Disconnected';\n        }\n    }\n    \n    /**\n     * Get risk level from score\n     */\n    getRiskLevel(score) {\n        if (score >= 0.9) return 'critical';\n        if (score >= 0.7) return 'high';\n        if (score >= 0.4) return 'medium';\n        return 'low';\n    }\n    \n    /**\n     * Mask customer ID for privacy\n     */\n    maskCustomerId(customerId) {\n        if (!customerId || customerId.length < 4) return customerId;\n        return customerId.slice(0, 2) + '*'.repeat(customerId.length - 4) + customerId.slice(-2);\n    }\n    \n    /**\n     * Format currency\n     */\n    formatCurrency(amount, currency = 'USD') {\n        return new Intl.NumberFormat('en-US', {\n            style: 'currency',\n            currency: currency,\n            minimumFractionDigits: 0,\n            maximumFractionDigits: 0\n        }).format(amount);\n    }\n    \n    /**\n     * Load initial data\n     */\n    async loadInitialData() {\n        try {\n            // Load recent transactions\n            const transactionsResponse = await fetch('/api/monitoring/transactions/recent');\n            if (transactionsResponse.ok) {\n                const transactions = await transactionsResponse.json();\n                this.monitoringData.transactions = transactions;\n            }\n            \n            // Load recent alerts\n            const alertsResponse = await fetch('/api/monitoring/alerts/recent');\n            if (alertsResponse.ok) {\n                const alerts = await alertsResponse.json();\n                this.monitoringData.alerts = alerts;\n            }\n            \n            // Initial chart updates\n            this.updateRiskDistributionChart();\n            this.updateAlertTrendsChart();\n            \n        } catch (error) {\n            console.error('Error loading initial data:', error);\n        }\n    }\n}\n\n// Initialize real-time monitor when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.realTimeMonitor = new RealTimeMonitor();\n});\n","size_bytes":22485}},"version":1}